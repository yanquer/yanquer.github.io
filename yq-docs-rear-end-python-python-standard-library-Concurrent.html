
<!DOCTYPE HTML>
<!--
	Dopetrope 2.0 by HTML5 UP
	html5up.net | @n33co
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html data-theme="dark">
	<head>
			<title>书言</title>
			<meta http-equiv="content-type" content="text/html; charset=utf-8" />
			<meta charset="utf-8" />

			<!-- <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,900,300italic" rel="stylesheet" /> -->
			<link rel="stylesheet" href="/theme/css/custom-pygment.css" />
			<noscript>
				<link rel="stylesheet" href="/theme/css/skel-noscript.css" />
				<link rel="stylesheet" href="/theme/css/style.css" />
				<link rel="stylesheet" href="/theme/css/style-desktop.css" />
			</noscript>

		<!-- tipuesearch 放在这, 因为搜索框是全局定义的 -->
		<link rel="stylesheet" href="/theme//Tipue-Search-5.0.0/tipuesearch.css" />
		<link rel="stylesheet" href="/theme//Tipue-Search-5.0.0/custom/tipuesearch-custom.css" />
		<link rel="stylesheet" href="/theme/css/alabaster.css" />
		<!-- <link rel="stylesheet" href="/theme/fontawesome-free-6.5.1-web/css/all.min.css" /> -->
		<!--  <link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-brands-400.woff2" />
		<link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-regular-400.woff2" />
		<link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-solid-900.woff2" />
		<link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-v4compatibility.woff2" /> -->


	</head>
	<body class="no-sidebar">

		<!-- 内容 -->
		<div>

			<!-- Header Wrapper -->
			<div id="header-wrapper">
				<div class="container">
					<div class="row">
						<div class="12u">

							<!-- Header -->
								<section id="header">

									<!-- Logo -->
									<div class="page-home">
										<h1><a href="/">HOME</a></h1>
									</div>

									<!-- Nav -->
									<div class="page-menu">
										<nav id="nav">
											<ul>

												<!-- categories -->
														<li ><a href="/category/ai.html">AI</a></li>
														<li ><a href="/category/an-quan.html">安全</a></li>
														<li ><a href="/category/ban-ben-kong-zhi.html">版本控制</a></li>
														<li ><a href="/category/cao-zuo-xi-tong.html">操作系统</a></li>
														<li ><a href="/category/chang-yong-gong-ju-shi-yong.html">常用工具使用</a></li>
														<li ><a href="/category/da-shu-ju.html">大数据</a></li>
														<li><a href="/categories.html">More...</a></li>
											</ul>
										</nav>
									</div>
								</section>

						</div>
					</div>
					<div class="row page-head-search">
						<form class="navbar-search" action="/search.html" role="search">
							<!-- <button class="fa-solid fa-magnifying-glass" type="submit"></button> -->
							<button type="submit"></button>
							<input type="text" name="q" id="tipue_search_input" autocomplete="off" placeholder="Search...">
							<!-- <i class="fa-solid fa-magnifying-glass"></i> -->
						</form>
					</div>
  <div class="row page-head page-article persistent">
    <div class="page-head-title">
      <h2>concurrent</h2>
    </div>
    <div class="page-head-content">
      By
	  <a href="author/yanque.html">YanQue</a>
      , 21 二月 2024
      , Category:
	  <a href="category/hou-duan-python.html">后端; python</a>
    </div>
	<div class="red-line">
    </div>
  </div>
				</div>

				<!-- 头部下方动效 -->
				<div class="waves-area">
					<section class="main-hero-waves-area waves-area">
						<svg class="waves-svg" preserveAspectRatio="none" shape-rendering="auto" viewBox="0 24 150 28"
							 xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg">
							<defs>
								<path
										d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"
										id="gentle-wave"></path>
							</defs>
							<g class="parallax">
								<use href="#gentle-wave" x="48" y="0"></use>
								<use href="#gentle-wave" x="48" y="3"></use>
								<use href="#gentle-wave" x="48" y="5"></use>
								<use href="#gentle-wave" x="48" y="7"></use>
							</g>
						</svg>
					</section>
				</div>

			</div>

		<!-- Main Wrapper -->
			<div id="main-wrapper">
				<div class="container">
<div class="row">
	<div class="12u">
			<section>
				<div>
					<div class="row">
						<div class="12u skel-cell-mainContent">
							<!-- Content -->
								<article class="box is-post">
									<div class="box-head">
										<div class="post-infos">
											<ul class="tags">
												<li><a class="button" href="category/hou-duan-python.html">后端; python</a></li>
													<li><a class="button button-alt" href="tag/python.html">Python</a></li>

													<li><a class="button button-alt" href="tag/pythonbiao-zhun-ku.html">Python标准库</a></li>

											</ul>
										</div>

										<div class="pennant pennant-alt date">2024-02-21</div>
										<h2>concurrent</h2>

										<span class="head-modify-time">修改于: 2024-02-21</span>

									</div>
									<p>官网: <a class="reference external" href="https://docs.python.org/zh-cn/3/library/concurrent.html">https://docs.python.org/zh-cn/3/library/concurrent.html</a></p>
<p>目前就一个包:</p>
<ul class="simple">
<li><tt class="docutils literal">concurrent.futures</tt> —— 启动并行任务</li>
</ul>
<div class="section" id="concurrent-futures">
<h2>concurrent.futures</h2>
<p>模块提供异步执行可调用对象高层接口。</p>
<p>异步执行可以由 <a class="reference internal" href="#threadpoolexecutor">ThreadPoolExecutor</a> 使用线程或由 <a class="reference internal" href="#processpoolexecutor">ProcessPoolExecutor</a> 使用单独的进程来实现。
两者都是实现抽像类 Executor 定义的接口。</p>
</div>
<div class="section" id="executor">
<span id="concurrent-executor-funs"></span><h2>Executor</h2>
<dl class="docutils">
<dt>class concurrent.futures.Executor</dt>
<dd><p class="first">抽象类提供异步执行调用方法。要通过它的子类调用，而不是直接调用。</p>
<div class="rst-function section" id="submit(fn, /, *args, **kwargs)">
<strong>submit(fn, /, *args, **kwargs)</strong><p></p>
<p>调度可调用对象 fn，以 <tt class="docutils literal"><span class="pre">fn(*args,</span> **kwargs)</tt> 方式执行并返回一个代表该可调用对象的执行的 Future 对象:</p>
<pre class="literal-block">
with ThreadPoolExecutor(max_workers=1) as executor:
    future = executor.submit(pow, 323, 1235)
    print(future.result())
</pre>
</div>
<div class="rst-function section" id="map(func, *iterables, timeout=None, chunksize=1)">
<strong>map(func, *iterables, timeout=None, chunksize=1)</strong><p></p>
<p>类似于 <tt class="docutils literal">map(func, *iterables)</tt> 函数，除了以下两点:</p>
<ul class="simple">
<li>iterables 是立即执行而不是延迟执行的；</li>
<li>func 是异步执行的，对 func 的多个调用可以并发执行。</li>
</ul>
<dl class="docutils">
<dt>timeout: Union[int, float, None]</dt>
<dd>当超时时, 将会触发 超时 异常(raises TimeoutError)</dd>
</dl>
<p>如果 func 调用引发一个异常，当从迭代器中取回它的值时这个异常将被引发。</p>
<p>使用 ProcessPoolExecutor 时，这个方法会将 iterables 分割任务块并作为独立的任务并提交到执行池中。
这些块的大概数量可以由 chunksize 指定正整数设置。
对很长的迭代器来说，使用大的 chunksize 值比默认值 1 能显著地提高性能。 chunksize 对 ThreadPoolExecutor 没有效果。</p>
<p>返回的是执行结果的生成器迭代, 保持于 iterables 的顺序一致:</p>
<pre class="literal-block">
from concurrent.futures import ThreadPoolExecutor

with ThreadPoolExecutor(max_workers=3) as t:
    d = t.map(lambda x: x**2, [1, 2, 3, 8])
    print(type(d))
    for x in d:
        print(x, type(x))
</pre>
<p>输出:</p>
<pre class="literal-block">
&lt;class 'generator'&gt;
1 &lt;class 'int'&gt;
4 &lt;class 'int'&gt;
9 &lt;class 'int'&gt;
64 &lt;class 'int'&gt;
</pre>
<p>在 3.5 版更改: 加入 chunksize 参数。</p>
</div>
<div class="rst-function last section" id="shutdown(wait=True, *, cancel_futures=False)">
<strong>shutdown(wait=True, *, cancel_futures=False)</strong><p></p>
<p>当待执行的 future 对象完成执行后向执行者发送信号，它就会释放正在使用的任何资源。
在关闭后调用 Executor.submit() 和 Executor.map() 将会引发 RuntimeError。</p>
<dl class="docutils">
<dt>wait: bool = True</dt>
<dd><p class="first">wait 为 True, 则此方法只有在所有待执行的 future 对象完成执行且释放已分配的资源后才会返回。</p>
<p>wait 为 False，方法立即返回，所有待执行的 future 对象完成执行后会释放已分配的资源。</p>
<p class="last">不管 wait 的值是什么，整个 Python 程序将等到所有待执行的 future 对象完成执行后才退出。</p>
</dd>
<dt>cancel_futures: bool=False</dt>
<dd>cancel_futures 为 True，此方法将取消所有执行器还未开始运行的挂起的 Future。
任何已完成或正在运行的 Future 将不会被取消，无论 cancel_futures 的值是什么？</dd>
</dl>
<p>如果 cancel_futures 和 wait 均为 True，则执行器已开始运行的所有 Future 将在此方法返回之前完成。 其余的 Future 会被取消。</p>
<p>如果使用 with 语句，你就可以避免显式调用这个方法，
它将会停止 Executor (就好像 Executor.shutdown() 调用时 wait 设为 True 一样等待):</p>
<pre class="literal-block">
import shutil
with ThreadPoolExecutor(max_workers=4) as e:
    e.submit(shutil.copy, 'src1.txt', 'dest1.txt')
    e.submit(shutil.copy, 'src2.txt', 'dest2.txt')
    e.submit(shutil.copy, 'src3.txt', 'dest3.txt')
    e.submit(shutil.copy, 'src4.txt', 'dest4.txt')
</pre>
<p>在 3.9 版更改: 增加了 cancel_futures。</p>
</div>
</dd>
</dl>
</div>
<div class="section" id="threadpoolexecutor">
<h2>ThreadPoolExecutor</h2>
<p>concurrent.futures.ThreadPoolExecutor</p>
<p>ThreadPoolExecutor 是 <a class="reference internal" href="#executor">Executor</a> 的子类，它使用线程池来异步执行调用。</p>
<p>当可调用对象已关联了一个 Future 然后在等待另一个 Future 的结果时就会导致死锁情况。例如:</p>
<pre class="literal-block">
import time
def wait_on_b():
    time.sleep(5)
    print(b.result())  # b will never complete because it is waiting on a.
    return 5

def wait_on_a():
    time.sleep(5)
    print(a.result())  # a will never complete because it is waiting on b.
    return 6

executor = ThreadPoolExecutor(max_workers=2)
a = executor.submit(wait_on_b)
b = executor.submit(wait_on_a)
</pre>
<p>与:</p>
<pre class="literal-block">
def wait_on_future():
    f = executor.submit(pow, 5, 2)
    # This will never complete because there is only one worker thread and
    # it is executing this function.
    print(f.result())

executor = ThreadPoolExecutor(max_workers=1)
executor.submit(wait_on_future)
</pre>
</div>
<div class="section" id="processpoolexecutor">
<h2>ProcessPoolExecutor</h2>
<p>ProcessPoolExecutor 类是 <a class="reference internal" href="#executor">Executor</a> 的子类，它使用进程池来异步地执行调用。
ProcessPoolExecutor 会使用 <a class="reference external" href="/yq-docs-rear-end-python-python-standard-library-multiprocessing.html">multiprocessing</a> 模块，
这允许它绕过 全局解释器锁 但也意味着只可以处理和返回可封存的对象。</p>
<p><tt class="docutils literal">__main__</tt> 模块必须可以被工作者子进程导入。这意味着 ProcessPoolExecutor 不可以工作在交互式解释器中。</p>
<p>从可调用对象中调用 <a class="reference internal" href="#executor">Executor</a> 或 <a class="reference internal" href="#future">Future</a> 的方法提交给 ProcessPoolExecutor 会导致死锁。</p>
<dl class="docutils">
<dt>class concurrent.futures.ProcessPoolExecutor(max_workers=None, mp_context=None, initializer=None, initargs=(), max_tasks_per_child=None)</dt>
<dd><p class="first">异步地执行调用的 <a class="reference internal" href="#executor">Executor</a> 子类使用最多具有 max_workers 个进程的进程池。</p>
<dl class="docutils">
<dt>max_workers:</dt>
<dd><p class="first">如果 max_workers 为 None 或未给出，它将默认为机器的处理器个数。
如果 max_workers 小于等于 0，则将引发 ValueError。</p>
<p class="last">在 Windows 上，max_workers 必须小于等于 61，否则将引发 ValueError。
如果 max_workers 为 None，则所选择的默认值最多为 61，即使存在更多的处理器。</p>
</dd>
<dt>mp_context:</dt>
<dd><p class="first">可以是一个多进程上下文或是 None。 它将被用来启动工作进程。</p>
<p class="last">如果 mp_context 为 None 或未给出，则将使用默认的多进程上下文。</p>
</dd>
<dt>initializer:</dt>
<dd>一个可选的可调用对象，它会在每个工作进程启动时被调用；</dd>
<dt>initargs:</dt>
<dd>传给 initializer 的参数元组。
如果 initializer 引发了异常，则所有当前在等待的任务以及任何向进程池提交更多任务的尝试都将引发 BrokenProcessPool。</dd>
<dt>max_tasks_per_child: = None</dt>
<dd><p class="first">可选参数, 表示单个进程可执行的最大任务数. 超出将会使用新的进程(刷新).</p>
<p>默认 None 表示工作进程将会一直存活到进程池终止.</p>
<p>在默认情况,缺少MP_CONTEXT参数, 且指定了最大值时，将使用 spawn() 多进程启动方法.</p>
<p class="last">与 fork() 启动方式不兼容.</p>
</dd>
</dl>
<p>在 3.3 版更改:
如果其中一个工作进程被突然终止，BrokenProcessPool 就会马上触发。
可预计的行为没有定义，但执行器上的操作或它的 future 对象会被冻结或死锁。</p>
<p>在 3.7 版更改: 添加 mp_context 参数允许用户控制由进程池创建给工作者进程的开始方法 。</p>
<p>加入 initializer 和*initargs* 参数。</p>
<p class="last">在 3.11 版更改: The max_tasks_per_child argument was added to allow users
to control the lifetime of workers in the pool.</p>
</dd>
</dl>
</div>
<div class="section" id="future">
<span id="concurrent-future"></span><h2>Future</h2>
<p>Future 类将可调用对象封装为异步执行。Future 实例由 <tt class="docutils literal">Executor.submit()</tt> 创建。</p>
<dl class="docutils">
<dt>class concurrent.futures.Future</dt>
<dd><p class="first">将可调用对象封装为异步执行。Future 实例由 Executor.submit() 创建，除非测试，不应直接创建。</p>
<div class="rst-function section" id="cancel()">
<strong>cancel()</strong><p></p>
<p>尝试取消调用。 如果调用正在执行或已结束运行不能被取消则该方法将返回 False，否则调用会被取消并且该方法将返回 True。</p>
</div>
<div class="rst-function section" id="cancelled()">
<strong>cancelled()</strong><p></p>
<p>如果调用成功取消返回 True。</p>
</div>
<div class="rst-function section" id="running()">
<strong>running()</strong><p></p>
<p>如果调用正在执行而且不能被取消那么返回 True 。</p>
</div>
<div class="rst-function section" id="done()">
<strong>done()</strong><p></p>
<p>如果调用已被取消或正常结束那么返回 True。</p>
</div>
<div class="rst-function section" id="result(timeout=None)">
<strong>result(timeout=None)</strong><p></p>
<p>Return the value returned by the call.
If the call hasn't yet completed then this method will wait up to timeout seconds.
If the call hasn't completed in timeout seconds, then a TimeoutError will be raised.
timeout can be an int or float.
If timeout is not specified or None, there is no limit to the wait time.</p>
<p>如果 futrue 在完成前被取消则 CancelledError 将被触发。</p>
<p>如果调用引发了一个异常，这个方法也会引发同样的异常。</p>
</div>
<div class="rst-function section" id="exception(timeout=None)">
<strong>exception(timeout=None)</strong><p></p>
<p>Return the exception raised by the call.
If the call hasn't yet completed then this method will wait up to timeout seconds.
If the call hasn't completed in timeout seconds, then a TimeoutError will be raised.
timeout can be an int or float.
If timeout is not specified or None, there is no limit to the wait time.</p>
<p>如果 futrue 在完成前被取消则 CancelledError 将被触发。</p>
<p>如果调用正常完成那么返回 None。</p>
</div>
<div class="rst-function section" id="add_done_callback(fn)">
<strong>add_done_callback(fn)</strong><p></p>
<p>附加可调用 fn 到 future 对象。
当 future 对象被取消或完成运行时，将会调用 fn，而这个 future 对象将作为它唯一的参数。</p>
<p>加入的可调用对象总被属于添加它们的进程中的线程按加入的顺序调用。
如果可调用对象引发一个 Exception 子类，它会被记录下来并被忽略掉。
如果可调用对象引发一个 BaseException 子类，这个行为没有定义。</p>
<p>如果 future 对象已经完成或已取消，fn 会被立即调用。</p>
</div>
<p><strong>下面这些 Future 方法用于单元测试和 Executor 实现.</strong></p>
<div class="rst-function section" id="set_running_or_notify_cancel()">
<strong>set_running_or_notify_cancel()</strong><p></p>
<p>这个方法只可以在执行关联 Future 工作之前由 Executor 实现调用或由单测试调用。</p>
<p>线程将会等待 Future实例 执行完成. 类似执行 as_completed() or wait()</p>
<dl class="docutils">
<dt>Return:</dt>
<dd><dl class="first last docutils">
<dt>False:</dt>
<dd>Future实例被退出. 类似 Future.cancel() == True</dd>
<dt>True:</dt>
<dd>Future实例不可退出, 处于 running 状态. Future.running() == True.</dd>
</dl>
</dd>
</dl>
<p>这个方法只可以被调用一次并且不能在调用 Future.set_result() 或 Future.set_exception() 之后再调用。</p>
</div>
<div class="rst-function section" id="set_result(result)">
<strong>set_result(result)</strong><p></p>
<p>设置将 Future 关联工作的结果给 result 。</p>
<p>这个方法只可以由 Executor 实现和单元测试使用。</p>
<p>在 3.8 版更改: 如果 Future 已经完成则此方法会引发 concurrent.futures.InvalidStateError。</p>
</div>
<div class="rst-function last section" id="set_exception(exception)">
<strong>set_exception(exception)</strong><p></p>
<p>设置 Future 关联工作的结果给 Exception exception 。</p>
<p>这个方法只可以由 Executor 实现和单元测试使用。</p>
<p>在 3.8 版更改: 如果 Future 已经完成则此方法会引发 concurrent.futures.InvalidStateError。</p>
</div>
</dd>
</dl>
</div>
<div class="section" id="section-1">
<h2>模块函数</h2>
<ul class="simple">
<li>wait</li>
<li>as_completed</li>
</ul>
<div class="rst-function section" id="concurrent.futures.wait(fs, timeout=None, return_when=ALL_COMPLETED)">
<strong>concurrent.futures.wait(fs, timeout=None, return_when=ALL_COMPLETED)</strong><p></p>
<p>等待由 fs 指定的 Future 实例（可能由不同的 Executor 实例创建）完成。
重复传给 fs 的 future 会被移除并将只返回一次。</p>
<p>返回一个由集合组成的具名 2 元组。</p>
<ul class="simple">
<li>第一个集合的名称为 done，包含在等待完成之前已完成的 future（包括正常结束或被取消的 future）。</li>
<li>第二个集合的名称为 not_done，包含未完成的 future（包括挂起的或正在运行的 future）。</li>
</ul>
<dl class="docutils">
<dt>timeout: Union[int, float, None]</dt>
<dd><p class="first">timeout 可以用来控制返回前最大的等待秒数。</p>
<p class="last">如果 timeout 未指定或为 None ，则不限制等待时间。</p>
</dd>
<dt>return_when:</dt>
<dd><p class="first">指定此函数应在何时返回。它必须为以下常数之一:</p>
<table border="1" class="last docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">常量</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>FIRST_COMPLETED</td>
<td>函数将在任意可等待对象结束或取消时返回。</td>
</tr>
<tr><td>FIRST_EXCEPTION</td>
<td>函数将在任意可等待对象因引发异常而结束时返回。当没有引发任何异常时它就相当于 ALL_COMPLETED。</td>
</tr>
<tr><td>ALL_COMPLETED</td>
<td>函数将在所有可等待对象结束或取消时返回。</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</div>
<div class="rst-function section" id="concurrent.futures.as_completed(fs, timeout=None)">
<strong>concurrent.futures.as_completed(fs, timeout=None)</strong><p></p>
<p>返回多个已执行完成的 <a class="reference internal" href="#future">Future</a> 对象的迭代器(状态: 执行完成或退出)</p>
<p>调用之前就完成的回最先返回.</p>
<dl class="docutils">
<dt>fs:</dt>
<dd>多个 <a class="reference internal" href="#future">Future</a> 对象的列表</dd>
<dt>timeout: Union[int, float, None]</dt>
<dd>.</dd>
</dl>
</div>
</div>
<div class="section" id="exception">
<h2>Exception 类</h2>
<ul class="simple">
<li>CancelledError</li>
<li>TimeoutError</li>
<li>BrokenExecutor</li>
<li>InvalidStateError</li>
<li>BrokenThreadPool</li>
<li>BrokenProcessPool</li>
</ul>
<div class="rst-function section" id="exception concurrent.futures.CancelledError">
<strong>exception concurrent.futures.CancelledError</strong><p></p>
<p>future 对象被取消时会触发。</p>
</div>
<div class="rst-function section" id="exception concurrent.futures.TimeoutError">
<strong>exception concurrent.futures.TimeoutError</strong><p></p>
<p>A deprecated alias of TimeoutError, raised when a future operation exceeds the given timeout.</p>
<p>在 3.11 版更改: This class was made an alias of TimeoutError.</p>
</div>
<div class="rst-function section" id="exception concurrent.futures.BrokenExecutor">
<strong>exception concurrent.futures.BrokenExecutor</strong><p></p>
<p>当执行器被某些原因中断而且不能用来提交或执行新任务时就会被引发派生于 RuntimeError 的异常类。</p>
<p>3.7 新版功能.</p>
</div>
<div class="rst-function section" id="exception concurrent.futures.InvalidStateError">
<strong>exception concurrent.futures.InvalidStateError</strong><p></p>
<p>当某个操作在一个当前状态所不允许的 future 上执行时将被引发。</p>
<p>3.8 新版功能.</p>
</div>
<div class="rst-function section" id="exception concurrent.futures.thread.BrokenThreadPool">
<strong>exception concurrent.futures.thread.BrokenThreadPool</strong><p></p>
<p>当 ThreadPoolExecutor 中的其中一个工作者初始化失败时会引发派生于 BrokenExecutor 的异常类。</p>
<p>3.7 新版功能.</p>
</div>
<div class="rst-function section" id="exception concurrent.futures.process.BrokenProcessPool">
<strong>exception concurrent.futures.process.BrokenProcessPool</strong><p></p>
<p>当 ThreadPoolExecutor 中的其中一个工作者不完整终止时(比如，被外部杀死)
会引发派生于 BrokenExecutor ( 原名 RuntimeError ) 的异常类。</p>
<p>3.3 新版功能.</p>
</div>
</div>

								</article>
						</div>
					</div>
				</div>
			</section>
	</div>
</div>

				</div>
			</div>



		<!-- Sider Bar -->
		<div id="right-side-bar">
	<nav>
		<div id="top-toc-tree-container" class="fixed-container">
			<div class="toc-contents-title">
				<h4 id="toc-contents-title-text">Contents</h4>
				<!-- <span class="tool-tip-text">点击隐藏</span> -->
			</div>
			<div id="toc-tree-container">
 <ul class="toc-tree visible">
  <li class="toc-h0">
   <a class="" href="#concurrent-futures">
    concurrent.futures
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#executor">
    Executor
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#threadpoolexecutor">
    ThreadPoolExecutor
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#processpoolexecutor">
    ProcessPoolExecutor
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#future">
    Future
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-1">
    模块函数
   </a>
   <ul class="toc-tree visible">
    <li class="toc-h1">
     <a class="" href="#concurrent.futures.wait(fs, timeout=None, return_when=ALL_COMPLETED)">
     </a>
    </li>
    <li class="toc-h1">
     <a class="" href="#concurrent.futures.as_completed(fs, timeout=None)">
     </a>
    </li>
   </ul>
  </li>
  <li class="toc-h0">
   <a class="" href="#exception">
    Exception 类
   </a>
   <ul class="toc-tree visible">
    <li class="toc-h1">
     <a class="" href="#exception concurrent.futures.CancelledError">
     </a>
    </li>
    <li class="toc-h1">
     <a class="" href="#exception concurrent.futures.TimeoutError">
     </a>
    </li>
    <li class="toc-h1">
     <a class="" href="#exception concurrent.futures.BrokenExecutor">
     </a>
    </li>
    <li class="toc-h1">
     <a class="" href="#exception concurrent.futures.InvalidStateError">
     </a>
    </li>
    <li class="toc-h1">
     <a class="" href="#exception concurrent.futures.thread.BrokenThreadPool">
     </a>
    </li>
    <li class="toc-h1">
     <a class="" href="#exception concurrent.futures.process.BrokenProcessPool">
     </a>
    </li>
   </ul>
  </li>
 </ul>
</div>

		</div>
	</nav>
	<div id="sidebar-tools" class="fixed-container no-active cant-select">
		<!-- 按钮 使用 content 绘制图标 -->
	</div>
	<div id="sidebar-tool-back-top" class="fixed-container cant-select">
		<!-- 按钮 使用 content 绘制图标 -->
	</div>
		</div>

		<!-- Footer Wrapper -->
			<div id="footer-wrapper">
				<!-- Footer -->
					<section id="footer" class="container">
						<div class="row">
							<div class="8u">
								<section>
									<header>
										<h2>Latest articles</h2>
									</header>
									<ul class="dates">
										<li>
											<span class="date"> 7 <strong>04</strong></span>
											<h3><a href="yq-docs-rear-end-swift-turtorial-container-layout-horizontal.html">SwiftUI水平容器布局</a></h3>
											<p><p class="first last">SwiftUI水平容器布局</p>
</p>
										</li>
										<li>
											<span class="date"> 7 <strong>04</strong></span>
											<h3><a href="yq-docs-rear-end-swift-turtorial-inner-outer-margin.html">SwiftUI内外边距</a></h3>
											<p><p class="first last">SwiftUI内外边距</p>
</p>
										</li>
										<li>
											<span class="date"> 7 <strong>01</strong></span>
											<h3><a href="yq-docs-operating-system-Windows-windows_shell-netstat.html">netstat</a></h3>
											<p><p class="first last">netstat-windows</p>
</p>
										</li>
										<li>
											<span class="date"> 7 <strong>01</strong></span>
											<h3><a href="yq-docs-operating-system-linux-Istoreos-tutorial-docker-add-trust-certificate.html">教程-Docker添加信任证书</a></h3>
											<p><p class="first last">教程-Docker添加信任证书</p>
</p>
										</li>
									</ul>
								</section>
							</div>
						</div>
						<div class="row">
							<div class="4u">
								<section>
									<header>
										<h2>Blogroll</h2>
									</header>
									<ul class="divided">
											<li><a href="https://yq-yqr.readthedocs.io/zh/blog-theme/blog.html">旧版(迁移中)</a></li>
											<li><a href="https://getpelican.com/">Pelican</a></li>
											<li><a href="https://www.python.org/">Python.org</a></li>
											<li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
									</ul>
								</section>
							</div>
							<div class="4u">
								<section>
									<header>
										<h2>Categories</h2>
									</header>
									<ul class="divided">
											<li><a href="/category/ai.html">AI</a></li>
											<li><a href="/category/an-quan.html">安全</a></li>
											<li><a href="/category/ban-ben-kong-zhi.html">版本控制</a></li>
											<li><a href="/category/cao-zuo-xi-tong.html">操作系统</a></li>
									</ul>
								</section>
							</div>

							<div class="4u">
								<section>
									<header>
										<h2>SITEMAP</h2>
									</header>

									<ul class="divided">
												<li><a href="/authors.html">作者</a></li>
												<li><a href="/categories.html">分类</a></li>
												<li><a href="/archives.html">归档</a></li>
												<li><a href="/tags.html">标签</a></li>
									</ul>
								</section>
							</div>

							<div class="4u">

								<section>
									<header>
										<h2>Contact</h2>
									</header>
									<ul class="social">
									</ul>
								</section>
							</div>
						</div>
						<div class="row">
							<div class="12u">
								<!-- Copyright -->
									<div id="copyright">
										<ul class="links">
											<li>&copy; YanQue 2021-2024	</li>
											<!-- <li>Images: <a href="http://facebook.com/DreametryDoodle">Dreametry Doodle</a> + <a href="http://iconify.it">Iconify.it</a></li>
											<li>Design: <a href="http://html5up.net">HTML5 UP</a></li> -->
										</ul>
									</div>
							</div>
						</div>
					</section>
			</div>

		</div>

		<!-- 其他 -->

			<div style="position: fixed;">
				<!-- 深色模式粒子效果 -->
				<!-- <canvas id="universe" width="1428" height="993" data-relingo-block="true" data-relingo-parsed="true"></canvas> -->
				<!-- 深色模式下添加粒子效果canvas -->
				<canvas id="universe" width="1312" height="880"></canvas>
			</div>

		<script src="/theme/js/jquery-3.7.1.min.js"></script>
		<script src="/theme/js/jquery.dropotron.js"></script>
		<script src="/theme/js/config.js"></script>
		<script src="/theme/skel-s0.4.8/skel.min.js"></script>
		<script src="/theme/skel-s0.4.8/skel-panels.min.js"></script>
		<!-- <script src="/theme/js/skel.min.js"></script>
		<script src="/theme/js/skel-panels.min.js"></script> -->
		<script src="/theme/js/backloading.js"></script>
		<script src="/theme/js/canvas/dark.js"></script>
<script type="text/javascript">
	function addEvent() {
		$("#toc-contents-title-text").click(function() {
			$("#top-toc-tree-container").toggleClass("no-active");
			$("#sidebar-tools").toggleClass("no-active");
		})
		$("#sidebar-tools").click(function() {
			$("#top-toc-tree-container").toggleClass("no-active");
			$("#sidebar-tools").toggleClass("no-active");
		})
		$("#sidebar-tool-back-top").click(function() {
			// window.scrollTo(0, 0);
			window.scrollTo({
				top: 0,
				left: 0,
				behavior: 'smooth'
			});
		})
	}
	addEvent()
</script>
		<!--[if lte IE 8]><script src="js/html5shiv.js"></script><link rel="stylesheet" href="/theme/css/ie8.css" /><![endif]-->
	</body>
</html>