
<!DOCTYPE HTML>
<!--
	Dopetrope 2.0 by HTML5 UP
	html5up.net | @n33co
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
			<title>书言</title>
			<meta http-equiv="content-type" content="text/html; charset=utf-8" />
			<meta charset="utf-8" />
			<link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,900,300italic" rel="stylesheet" />
				<link rel="stylesheet" href="/theme/css/pygment.css" />
			<noscript>
				<link rel="stylesheet" href="/theme/css/skel-noscript.css" />
				<link rel="stylesheet" href="/theme/css/style.css" />
				<link rel="stylesheet" href="/theme/css/style-desktop.css" />
			</noscript>
		<link rel="stylesheet" href="/theme/css/alabaster.css" />
		<link rel="stylesheet" href="/theme/css/style-update.css" />
	</head>
	<body class="no-sidebar">
		<!-- Header Wrapper -->
			<div id="header-wrapper">
				<div class="container">
					<div class="row">
						<div class="12u">

							<!-- Header -->
								<section id="header">

									<!-- Logo -->
									<div class="page-home">
										<h1><a href="/">HOME</a></h1>
									</div>

									<!-- Nav -->
									<div class="page-menu">
										<nav id="nav">
											<ul>

												<!-- categories -->
														<li ><a href="/category/ai.html">AI</a></li>
														<li ><a href="/category/an-quan.html">安全</a></li>
														<li ><a href="/category/ban-ben-kong-zhi.html">版本控制</a></li>
														<li ><a href="/category/cao-zuo-xi-tong.html">操作系统</a></li>
														<li ><a href="/category/chang-yong-gong-ju-shi-yong.html">常用工具使用</a></li>
														<li ><a href="/category/da-shu-ju.html">大数据</a></li>
														<li><a href="/categories.html">More...</a></li>
											</ul>
										</nav>
									</div>
								</section>

						</div>
					</div>
					<div class="row page-head-search">
						<form class="navbar-search" action="/search.html" role="search">
							<!-- <button class="fa-solid fa-magnifying-glass" type="submit"></button> -->
							<button type="submit"></button>
							<input type="text" name="q" id="tipue_search_input" autocomplete="off" placeholder="Search...">
							<!-- <i class="fa-solid fa-magnifying-glass"></i> -->
						</form>
					</div>
  <div class="row page-head page-article persistent">
    <div class="page-head-title">
      <h2>Celery的Task</h2>
    </div>
    <div class="page-head-content">
      By
	  <a href="author/yanque.html">YanQue</a>
      , 20 二月 2023
      , Category:
	  <a href="category/hou-duan.html">后端</a>
    </div>
	<div class="red-line">
    </div>
  </div>
				</div>
			</div>

		<!-- Main Wrapper -->
			<div id="main-wrapper">
				<div class="container">
<div class="row">
	<div class="12u">
			<section>
				<div>
					<div class="row">
						<div class="12u skel-cell-mainContent">
							<!-- Content -->
								<article class="box is-post">
									<div class="post-infos">
										<ul class="tags">
											<li><a class="button" href="category/hou-duan.html">后端</a></li>
												<li><a class="button button-alt" href="tag/python.html">Python</a></li>

												<li><a class="button button-alt" href="tag/pythonsan-fang-ku.html">Python三方库</a></li>

												<li><a class="button button-alt" href="tag/celery_more.html">Celery_more</a></li>

										</ul>
									</div>

									<div class="pennant pennant-alt date">2023-02-20</div>
									<h2>Celery的Task</h2>
									<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">参考::</th><td class="field-body"><a class="reference external" href="https://www.celerycn.io/v/4.4.0/yong-hu-zhi-nan/ren-wu-tasks">[Celery 中文手册] 任务: Tasks</a></td>
</tr>
</tbody>
</table>
<p>概念与 异步 的任务类似</p>
<div class="section" id="section-1">
<h2>基础</h2>
<p>使用 task() 装饰器轻松的创建任何可被调用的任务:</p>
<pre class="literal-block">
from .models import User

&#64;app.task
def create_user(username, password):
    User.objects.create(username=username, password=password)
</pre>
<p>支持指定参数:</p>
<pre class="literal-block">
&#64;app.task(serializer='json')
def create_user(username, password):
    User.objects.create(username=username, password=password)
</pre>
<p>注意, 若存在多个装饰器, <tt class="docutils literal">app.task</tt> 需要放在首位.</p>
<p>还有一个 <tt class="docutils literal">app.shared_task</tt> 待...</p>
</div>
<div class="section" id="section-2">
<h2>一些属性/方法</h2>
<div class="section" id="app-task">
<h3>app.task装饰器支持的参数</h3>
<dl class="docutils">
<dt>name:</dt>
<dd><p class="first">任务注册的名称。</p>
<p class="last">可以手动设置任务名称，也可以通过模块名和类名进行自动生成(默认行为)。</p>
</dd>
<dt>backend:</dt>
<dd>结果后端的实例，用于任务结果后端，默认为 app.backend，可以通过 result_backend 进行配置。</dd>
<dt>acks_late:</dt>
<dd><p class="first">如果设置为 True，任务执行后（而不是执行前，默认为执行前）才会确认该任务的消息。</p>
<p class="last">注意：如果职程（Worker）执行过程中崩溃，任务可能会执行多次。
可以通过 task_acks_late 参数来进行全局配置。</p>
</dd>
<dt>track_started:</dt>
<dd><p class="first">如果设置为 True，当职程（Worker）执行任务时，任务状态为 stared。</p>
<p>默认为 False，因为在正常情况下是不需要该颗粒度级别的。
任务要么挂起、完成要么等待重试。
如果有长时间运行的任务，并且需要报告任当任务状态时，stared比较有用。</p>
<p>任务执行的职程（Worker）和进程 id 可以通过状态的元数据中进行查看（例如：result.info['pid']）。</p>
<p class="last">可以通过 task_track_started 进行全局配置。</p>
</dd>
<dt>rate_limit: Union[int, float, None]</dt>
<dd><p class="first">配置任务的频率.</p>
<p>限制指定任务类型的速率（限制在指定时间内运行的任务数量）。当速率限制生效时，任务仍然会完成，但是可能需要一些时间才能开始。</p>
<p>如果限制速率为 None，表示速率限制无效.</p>
<p class="last">速率可以为 int 也可以为 float 类型，则被表示为“每秒任务数”。</p>
</dd>
<dt>bind: bool=False</dt>
<dd>为 Trur 时表示设置第一个参数为 self (task实例)</dd>
<dt>serializer: str</dt>
<dd><p class="first">设置序列化方式, 会覆盖掉初始配置.</p>
<p class="last">默认为 task_serializer，
也可以为 pickle、json、yaml 或者通过 kombu.serialization.registry 注册的自定义序列化方法。</p>
</dd>
<dt>request:</dt>
<dd>如果该任务正处于执行状态，该信息包含该任务的请求信息。使用多线程本地存储。
见: <a class="reference internal" href="#request">request</a></dd>
<dt>throws: tuple</dt>
<dd>预期内的异常，如果在元组中含有该异常类，将不会被视为异常。 但是日志会记录到结果后端.</dd>
<dt>time_limit:</dt>
<dd>该任务的硬时间限制（以秒为单位），如果没有设置职程（Worker）时，使用默认值。</dd>
<dt>soft_time_limit:</dt>
<dd>该任务的软时间限制（以秒为单位），如果没有设置职程（Worker）时，使用默认值。</dd>
<dt>ignore_result:</dt>
<dd><p class="first">不存储任务状态信息，如果配置该选项 AsyncResult 将失效，无法进行检测任务情况以及返回内容。</p>
<p class="last">如果你并不关心任务的结果，请务必确定设置 ignore_result 选项，因为存储结果会浪费时间和资源。</p>
</dd>
<dt>store_errors_even_if_ignored:</dt>
<dd>如果设置为 True ，即使任务被忽略，也会存储错误信息。</dd>
<dt>compression:</dt>
<dd><p class="first">标识需要使用默认压缩方法的字符串。</p>
<p class="last">默认为 task_compression，可以设置为 gzip、bzip2或通过 kombu.compression 注册的自定义压缩方案。</p>
</dd>
<dt>max_retries: int = 3</dt>
<dd><p class="first">当前任务调用 self 或使用 autoretry_for 参数时才会启用。</p>
<p>如果重试的次数超过最大限制，会引发 MaxRetriesExceededError 异常。在异常时不会自动重试，所以必须手动调用 retry()。</p>
<p>默认值重试次数为3次，如果设置为 None 会关闭重试限制，直到任务执行成功为止。</p>
<p>速率限制也可以在数值后面添加 &quot;/s&quot;、&quot;/m&quot; 或 &quot;/h&quot;，以秒、分钟或以小时为单位。任务将在指定的时间内平均分配。</p>
<p>例如: &quot;100/m&quot; （每分钟100个任务）。则强制会在同一个职程（Worker）实例上启动俩个任务之间至少 600ms 的延迟。</p>
<p>默认值通过 task_default_rate_limit 进行设定：如果未指定，表示默认情况禁用任务的速率限制。</p>
<p class="last">注意，该速率限制为每一个职程（Worker）实例的限制，并非全局速率限制。配置全局速率限制（例如，API每秒最多请求的次数），必须制定队列。</p>
</dd>
<dt>default_retry_delay: Union[int, float] = 30 * 60</dt>
<dd>如果任务需要重试, 设置每次重试之间的间隔时间. 单位: 秒(s)</dd>
<dt>autoretry_for:</dt>
<dd><p class="first">任务失败时重试, 相关的配置.
异常类的列表或元组，如果任务在执行的过程中引发异常，任务将自动重试。默认情况下不会自动重试任何异常。</p>
<p class="last">见 <a class="reference internal" href="#autoretry-for">autoretry_for</a></p>
</dd>
<dt>retry_kwargs: dict</dt>
<dd><p class="first">任务失败重试时相关配置. 自定义配置自动重试参数。</p>
<p>注意，如果使用下面的 exponential backoff 选项是，
countdown 任务选项将由 Celery 的自动重试系统决定，字典中包含 countdown 会被忽略。</p>
<p class="last">见 <a class="reference internal" href="#retry-kwargs">retry_kwargs</a></p>
</dd>
<dt>retry_backoff: Union[int, bool] = False</dt>
<dd><p class="first">如果将此选项设置为True，则自动重试将按照 exponential backoff 规则延迟。
第一次重试延迟 1 秒，第二次重试延迟 2 秒，第三次延迟 4 秒，第四次延迟 8 秒，以此类推。
（如果启用了 retry_jitter 会修改延迟值）。</p>
<p>如果该选项设置为数字，则作为延迟因子.
例如，该选项设置为 3，那么第一次重试将延迟 3 秒，第二次将延迟 6 秒，第三次延迟 12 秒，第四次延迟 24秒，以此类推。</p>
<p class="last">默认情况下，该选项设置为 False，自动重试不会延迟。</p>
</dd>
<dt>retry_backoff_max: int = 600</dt>
<dd><p class="first">如果启动了 retry_backoff，该选项在任务自动重试之间设置以秒为单位的最大延迟。</p>
<p class="last">默认情况，该选项默认值为 600，即 10分钟。</p>
</dd>
<dt>retry_jitter: bool = True</dt>
<dd><p class="first">Jitter 用于随机性引入指数回退延迟，防止队列中所有任务同时执行.</p>
<p class="last">如果该选项设置为 True，则将 retry_backoff 计算的延迟作为最大值，实际的延迟值为一个介于 0 和最大值之间的一个随机数。</p>
</dd>
</dl>
</div>
<div class="section" id="retry">
<h3>retry</h3>
<p>任务失败时的重试</p>
<p>当调用 retry 时，会发送与原始任务相同的ID发送一条消息，将该消息发送到原始任务的对列中。
当任务被重试时，也会被记录为一个任务状态，便于通过 result 实例来跟踪任务。</p>
<p>例:</p>
<pre class="literal-block">
&#64;app.task(bind=True)
def send_twitter_status(self, oauth, tweet):
    try:
        twitter = Twitter(oauth)
        twitter.update_status(tweet)
    except (Twitter.FailWhaleError, Twitter.LoginError) as exc:
        raise self.retry(exc=exc)
</pre>
<p>exc 参数主要用传递日志和存储任务结果时的使用的异常信息。exception 和 traceback 都将在任务状态中可用(如果启用了结果后端)。</p>
<p>任务如果有一个 max_retries 值，超出了重试的最大次数，则会重新引发当前的异常信息，但如果:</p>
<ul>
<li><p class="first">exc 参数没有设置
该情况会引发 MaxRetriesExceededError 异常</p>
</li>
<li><p class="first">没有异常
如果没有初始异常来重新引发exc参数，可以使用:</p>
<pre class="literal-block">
self.retry(exc=Twitter.LoginError())
</pre>
<p>设置 exc 参数值</p>
</li>
</ul>
</div>
<div class="section" id="request">
<h3>request</h3>
<p><a class="reference external" href="https://www.celerycn.io/v/4.4.0/yong-hu-zhi-nan/ren-wu-tasks/ren-wu-qing-qiu-task-request">任务请求：Task Request</a></p>
<p>app.Task.request 包含与当前执行任务相关的信息和状态。
该请求定义了以下属性:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">属性名称</th>
<th class="head">说明</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>id</td>
<td>执行任务的唯一ID</td>
</tr>
<tr><td>group</td>
<td>任务组的唯一ID（该任务是组成员的情况下）</td>
</tr>
<tr><td>chord</td>
<td>此任务所属的和弦的惟一id(如果该任务是标题的一部分)</td>
</tr>
<tr><td>correlation_id</td>
<td>用于重复数据删除的自定义ID</td>
</tr>
<tr><td>args</td>
<td>选项参数</td>
</tr>
<tr><td>kwargs</td>
<td>关键字参数</td>
</tr>
<tr><td>origin</td>
<td>发送任务的主机名</td>
</tr>
<tr><td>retries</td>
<td>任务重试次数，默认是从 0 开始的</td>
</tr>
<tr><td>is_eager</td>
<td>如果任务是由客户端执行，并非职程（Worker）执行，设置 True</td>
</tr>
<tr><td>expires</td>
<td>任务预计时间（如果已经设置的情况下），时间为 UTC 格式（取决于 enable_utc 设置）</td>
</tr>
<tr><td>hostname</td>
<td>执行任务的职程（Worker）实例的节点名</td>
</tr>
<tr><td>delivery_info</td>
<td>添加附加传递消息，主要用于包含交付任务的交换和路由键的映射，retry() 主要用于重新讲任务下发到队列中，该 dict 中的键可用取决于使用的消息中间人（Broker）。</td>
</tr>
<tr><td>reply-to</td>
<td>回复的发送的队列名称（例如，与 RPC 结果后端一起使用）</td>
</tr>
<tr><td>called_directly</td>
<td>如果职程（Worker）未执行任务，则此标志设置为true</td>
</tr>
<tr><td>timelimit</td>
<td>当前(软、硬)时间限制的元组(如果有的话)</td>
</tr>
<tr><td>callbacks</td>
<td>如果此任务成功返回，将调用的签名列表</td>
</tr>
<tr><td>errback</td>
<td>如果此任务失败，将调用的签名列表</td>
</tr>
<tr><td>utc</td>
<td>设置为 true ，启用 UTC</td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>headers</td>
<td>与任务消息一起发送的消息头的映射（可以为 None）</td>
</tr>
<tr><td>reply_to</td>
<td>回复的地址（队列名称）</td>
</tr>
<tr><td>correlation_id</td>
<td>一般与任务的ID相同，通常用于AMQP中跟踪回复的内容</td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>root_id</td>
<td>此任务所属工作流中的第一个任务的唯一ID（如果有）</td>
</tr>
<tr><td>parent_id</td>
<td>调用此任务的任务的惟一id（如果有）</td>
</tr>
<tr><td>chain</td>
<td>反转形成链的任务列表（如果有）。列表中最后一个任务是当前任务执行成功之后的下一个任务。如果使用任务协议的第一个版本，则链任务将位于 request.callbacks 中</td>
</tr>
</tbody>
</table>
<p>案例
访问上下文访问信息的一个任务案例:</p>
<pre class="literal-block">
&#64;app.task(bind=True)
def dump_context(self, x, y):
    print('Executing task id {0.id}, args: {0.args!r} kwargs: {0.kwargs!r}'.format(
            self.request))
</pre>
<p>bind 参数表示该函数绑是一个绑定方法，可以通过访问任务类型实例中的属性和方法。</p>
</div>
</div>
<div class="section" id="section-3">
<h2>任务重试</h2>
<div class="section" id="section-4">
<h3>使用装饰器参数的方式</h3>
<p id="autoretry-for">有时，您只想在引发特定异常时重试任务。 可也通过 Celery 中 task() 装饰器中的 autoretry_for 参数进行自动重试任务:</p>
<pre class="literal-block">
from twitter.exceptions import FailWhaleError

&#64;app.task(autoretry_for=(FailWhaleError,))
def refresh_timeline(user):
    return twitter.refresh_timeline(user)
</pre>
<p id="retry-kwargs">可以通过 task() 中的 retry_kwargs 参数来指定 retry() 内部调用参数:</p>
<pre class="literal-block">
&#64;app.task(autoretry_for=(FailWhaleError,),
          retry_kwargs={'max_retries': 5})
def refresh_timeline(user):
    return twitter.refresh_timeline(user)
</pre>
<p>上面的示例与在 try ... except 语句中包含的代码块使用 <a class="reference internal" href="#retry">retry</a> 效果一致:</p>
<pre class="literal-block">
&#64;app.task
def refresh_timeline(user):
    try:
        twitter.refresh_timeline(user)
    except FailWhaleError as exc:
        raise div.retry(exc=exc, max_retries=5)
</pre>
<p>如果你想自动重试任何错误，只需使用:</p>
<pre class="literal-block">
&#64;app.task(autoretry_for=(Exception,))
def x():
    ...
</pre>
</div>
<div class="section" id="section-5">
<h3>手动捕获的方式</h3>
<p>见 <a class="reference internal" href="#retry">retry</a></p>
</div>
</div>
<div class="section" id="section-6">
<h2>任务状态</h2>
<div class="section" id="section-7">
<h3>内置状态</h3>
<dl class="docutils">
<dt>PENDING</dt>
<dd>任务正在等待执行或未知。任何未知的任务 ID 都默认处于挂起状态。</dd>
<dt>STARTED</dt>
<dd><p class="first">任务已经开始。默认情况下不会记录，需要启用，请参阅 app.Task.track_started.。</p>
<p class="last">meta-data：正在执行任务的职程（Worker） pid 和主机名。</p>
</dd>
<dt>SUCCESS</dt>
<dd><p class="first">任务执行成功。</p>
<p class="last">meta-data：任务结果返回值 propagates：Yes ready: Yes</p>
</dd>
<dt>FAILURE</dt>
<dd>任务执行失败。
meta-data：执行异常时的任务信息，其中 traceback 包含引发错误的堆栈信息。 propagates：Yes</dd>
<dt>RETRY</dt>
<dd><p class="first">任务处于重试状态。</p>
<p class="last">meta-data：结果信息包含导致重试的异常信息，traceback 包含引发异常时堆栈的回溯。 propagates：No</p>
</dd>
<dt>REVOKED</dt>
<dd><p class="first">任务被撤销。</p>
<p class="last">propagates：Yes</p>
</dd>
</dl>
</div>
<div class="section" id="section-8">
<h3>自定义状态</h3>
<p><strong>使用 update_state() 更新任务状态</strong></p>
<p>只需要设置一个位置的名称，就可以轻松的自定义状态，状态名通常是大写的字符串。</p>
<p>例如，您可以查看定义自定义中止状态的可中止任务:</p>
<pre class="literal-block">
&#64;app.task(bind=True)
def upload_files(self, filenames):
    for i, file in enumerate(filenames):
        if not self.request.called_directly:
            self.update_state(state='PROGRESS',
                meta={'current': i, 'total': len(filenames)})
</pre>
<p>在这里，创建了一个名称为“ PROGRESS”的状态，通过 current 和 total 作为元数据的一部分，
计算任务当前正在进行状态的任何应用程序以及任务在进程中位置。可以通过该方法来创建任务进度条。</p>
</div>
</div>
<div class="section" id="section-9">
<h2>自定义任务类</h2>
<p>所有的任务都继承 app.Task 类，run() 方法为任务体。
例如:</p>
<pre class="literal-block">
&#64;app.task
def add(x, y):
    return x + y
</pre>
<p>在内部大概会是这样:</p>
<pre class="literal-block">
class _AddTask(app.Task):

    def run(self, x, y):
        return x + y
add = app.tasks[_AddTask.name]
</pre>
</div>
<div class="section" id="section-10">
<h2>任务调用</h2>
<ul class="simple">
<li><a class="reference internal" href="#apply-async">apply_async</a> , 发送一个任务消息</li>
<li><a class="reference internal" href="#delay">delay</a> ,       直接发送一个任务消息,但是不支持运行参数</li>
<li><a class="reference internal" href="#calling">calling</a> ,     应用一个支持调用接口（例如，add(2,2)）的对象,
意味着任务不会被一个 worker 执行,但是会在当前线程中执行(但是消息不会被发送)</li>
</ul>
<div class="section" id="apply-async">
<h3>apply_async</h3>
</div>
<div class="section" id="delay">
<h3>delay</h3>
</div>
<div class="section" id="calling">
<h3>calling</h3>
</div>
</div>
<div class="section" id="section-11">
<h2>任务回调</h2>
<p>task支持的函数回调</p>
<ul class="simple">
<li><a class="reference internal" href="#after-return">after_return</a>  任务返回后调用的处理程序</li>
<li><a class="reference internal" href="#on-failure">on_failure</a>    任务执行失败时，由职程（Worker）调用。</li>
<li><a class="reference internal" href="#on-retry">on_retry</a>      任务重试时，由职程（Worker）调用。</li>
<li><a class="reference internal" href="#on-success">on_success</a>    任务成功时，由职程（Worker）调用。</li>
</ul>
<div class="section" id="after-return">
<h3>after_return</h3>
</div>
<div class="section" id="on-failure">
<h3>on_failure</h3>
</div>
<div class="section" id="on-retry">
<h3>on_retry</h3>
</div>
<div class="section" id="on-success">
<h3>on_success</h3>
</div>
</div>
<div class="section" id="on-message">
<h2>获取回调改变/状态-on_message</h2>
<p>Celery 可以通过消息回调获取所有状态的改变。例如对于长时任务发送人任务进程，你可以这样做:</p>
<pre class="literal-block">
&#64;app.task(bind=True)
def hello(self, a, b):
    time.sleep(1)
    self.update_state(state=&quot;PROGRESS&quot;, meta={'progress': 50})
    time.sleep(1)
    self.update_state(state=&quot;PROGRESS&quot;, meta={'progress': 90})
    time.sleep(1)
    return 'hello world: %i' % (a+b)

def on_raw_message(body):
    print(body)

r = hello.apply_async(4, 6)
print(r.get(on_message=on_raw_message, propagate=False))
</pre>
<p>将生成如下输出:</p>
<pre class="literal-block">
{'task_id': '5660d3a3-92b8-40df-8ccc-33a5d1d680d7',
'result': {'progress': 50},
'children': [],
'status': 'PROGRESS',
'traceback': None}
{'task_id': '5660d3a3-92b8-40df-8ccc-33a5d1d680d7',
'result': {'progress': 90},
'children': [],
'status': 'PROGRESS',
'traceback': None}
{'task_id': '5660d3a3-92b8-40df-8ccc-33a5d1d680d7',
'result': 'hello world: 10',
'children': [],
'status': 'SUCCESS',
'traceback': None}
hello world: 10
</pre>
</div>
<div class="section" id="eta-and-countdown">
<h2>限制时间-ETA and Countdown</h2>
<p id="eta"><strong>ETA</strong> (estimated time of arrival, 预计到底时间) 让你设置一个日期和时间，在这个时间之前任务将被执行。</p>
<p id="countdown"><strong>countdown</strong> 是一种以秒为单位设置ETA的快捷方式:</p>
<pre class="literal-block">
&gt;&gt;&gt; result = add.apply_async((2, 2), countdown=3)
&gt;&gt;&gt; result.get()    # this takes at least 3 seconds to return
20
</pre>
<p>确保任务在指定的日期和时间之后的某个时间执行，但不一定在该时间执行。
可能原因可能包括许多项目在队列中等待，或者严重的网络延迟。为了确保您的任务及时执行，你应该监视队列中的拥塞情况。
使用Munin或类似工具来接收警报，因此可以采取适当的措施来减轻负载。点击查看Munin。</p>
<p>尽管 countdown 是整数，但eta必须是一个 datetime 对象，并指定确切的日期和时间（包括毫秒精度和时区信息）:</p>
<pre class="literal-block">
&gt;&gt;&gt; from datetime import datetime, timedelta

&gt;&gt;&gt; tomorrow = datetime.utcnow() + timedelta(days=1)
&gt;&gt;&gt; add.apply_async((2, 2), eta=tomorrow)
</pre>
<p id="expires"><strong>expries</strong> 参数定义了一个可选的到期时间，既可以作为任务之后秒发布，或在特定日期和时间使用 datetime:</p>
<pre class="literal-block">
&gt;&gt;&gt; # Task expires after one minute from now.
&gt;&gt;&gt; add.apply_async((10, 10), expires=60)

&gt;&gt;&gt; # Also supports datetime
&gt;&gt;&gt; from datetime import datetime, timedelta
&gt;&gt;&gt; add.apply_async((10, 10), kwargs,
...                 expires=datetime.now() + timedelta(days=1)
</pre>
<p>当 worker 收到过期的任务时，它将任务标记为REVOKED</p>
</div>
<div class="section" id="section-12">
<h2>创建连接池</h2>
<p>自动池支持</p>
<p>从2.3版开始，支持自动连接池，因此您不必手动处理连接和发布者即可重用连接。</p>
<p>从2.5版开始，默认情况下启用连接池。</p>
<p>您可以通过创建发布者来手动处理连接:</p>
<pre class="literal-block">
results = []
with add.app.pool.acquire(block=True) as connection:
    with add.get_publisher(connection) as publisher:
        try:
            for args in numbers:
                res = add.apply_async((2, 2), publisher=publisher)
                results.append(res)
print([res.get() for res in results])
</pre>
<p>尽管这是个特定示例，但是可以更好的展现一组:</p>
<pre class="literal-block">
&gt;&gt;&gt; from celery import group

&gt;&gt;&gt; numbers = [(2, 2), (4, 4), (8, 8), (16, 16)]
&gt;&gt;&gt; res = group(add.s(i, j) for i, j in numbers).apply_async()

&gt;&gt;&gt; res.get()
[4, 8, 16, 32]
</pre>
</div>

								</article>
						</div>
					</div>
				</div>
			</section>
	</div>
</div>

				</div>
			</div>

		<!-- Footer Wrapper -->
			<div id="footer-wrapper">
				<!-- Footer -->
					<section id="footer" class="container">
						<div class="row">
							<div class="8u">
								<section>
									<header>
										<h2>Latest articles</h2>
									</header>
									<ul class="dates">
										<li>
											<span class="date"> 3 <strong>19</strong></span>
											<h3><a href="yq-doc-source-docs-version-control-git-issuses-clone-only-folder.html">仅克隆指定文件夹</a></h3>
											<p><p class="first last">当前模块或子模块仅克隆指定文件夹</p>
</p>
										</li>
										<li>
											<span class="date"> 3 <strong>19</strong></span>
											<h3><a href="yq-doc-source-docs-rear-end-python-python-three--party-library-googletrans.html">googletrans</a></h3>
											<p><p class="first last">python实现翻译功能</p>
</p>
										</li>
										<li>
											<span class="date"> 3 <strong>18</strong></span>
											<h3><a href="yq-os-linux-ubuntu-issues.html">gnome刷新desktop缓存</a></h3>
											<p><p class="first last">gnome图标文件缓存刷新</p>
</p>
										</li>
										<li>
											<span class="date"> 3 <strong>17</strong></span>
											<h3><a href="yq-doc-vs-plugin.html">Vscode文档相关插件.rst</a></h3>
											<p><p class="first last">Vscode文档相关实用插件</p>
</p>
										</li>
									</ul>
								</section>
							</div>
						</div>
						<div class="row">
							<div class="4u">
								<section>
									<header>
										<h2>Blogroll</h2>
									</header>
									<ul class="divided">
											<li><a href="https://yq-yqr.readthedocs.io/zh/blog-theme/blog.html">旧版(迁移中)</a></li>
											<li><a href="https://getpelican.com/">Pelican</a></li>
											<li><a href="https://www.python.org/">Python.org</a></li>
											<li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
									</ul>
								</section>
							</div>
							<div class="4u">
								<section>
									<header>
										<h2>Categories</h2>
									</header>
									<ul class="divided">
											<li><a href="/category/ai.html">AI</a></li>
											<li><a href="/category/an-quan.html">安全</a></li>
											<li><a href="/category/ban-ben-kong-zhi.html">版本控制</a></li>
											<li><a href="/category/cao-zuo-xi-tong.html">操作系统</a></li>
									</ul>
								</section>
							</div>

							<div class="4u">
								<section>
									<header>
										<h2>SITEMAP</h2>
									</header>

									<ul class="divided">
												<li><a href="/authors.html">作者</a></li>
												<li><a href="/categories.html">分类</a></li>
												<li><a href="/archives.html">归档</a></li>
												<li><a href="/tags.html">标签</a></li>
									</ul>
								</section>
							</div>

							<div class="4u">

								<section>
									<header>
										<h2>Contact</h2>
									</header>
									<ul class="social">
									</ul>
								</section>
							</div>
						</div>
						<div class="row">
							<div class="12u">
								<!-- Copyright -->
									<div id="copyright">
										<ul class="links">
											<li>&copy; YanQue 2021-2024	</li>
											<!-- <li>Images: <a href="http://facebook.com/DreametryDoodle">Dreametry Doodle</a> + <a href="http://iconify.it">Iconify.it</a></li>
											<li>Design: <a href="http://html5up.net">HTML5 UP</a></li> -->
										</ul>
									</div>
							</div>
						</div>
					</section>
			</div>
		<script src="/theme/js/jquery.min.js"></script>
		<script src="/theme/js/jquery.dropotron.js"></script>
		<script src="/theme/js/config.js"></script>
		<script src="/theme/js/skel.min.js"></script>
		<script src="/theme/js/skel-panels.min.js"></script>
		<!--[if lte IE 8]><script src="js/html5shiv.js"></script><link rel="stylesheet" href="/theme/css/ie8.css" /><![endif]-->
	</body>
</html>