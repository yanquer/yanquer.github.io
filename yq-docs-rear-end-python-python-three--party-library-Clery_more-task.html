
<!DOCTYPE HTML>
<!--
	Dopetrope 2.0 by HTML5 UP
	html5up.net | @n33co
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html data-theme="dark">
	<head>
			<title>书言</title>
			<meta http-equiv="content-type" content="text/html; charset=utf-8" />
			<meta charset="utf-8" />

			<!-- <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,900,300italic" rel="stylesheet" /> -->
			<link rel="stylesheet" href="/theme/css/custom-pygment.css" />
			<noscript>
				<link rel="stylesheet" href="/theme/css/skel-noscript.css" />
				<link rel="stylesheet" href="/theme/css/style.css" />
				<link rel="stylesheet" href="/theme/css/style-desktop.css" />
			</noscript>

		<!-- tipuesearch 放在这, 因为搜索框是全局定义的 -->
		<link rel="stylesheet" href="/theme//Tipue-Search-5.0.0/tipuesearch.css" />
		<link rel="stylesheet" href="/theme//Tipue-Search-5.0.0/custom/tipuesearch-custom.css" />
		<link rel="stylesheet" href="/theme/css/alabaster.css" />
		<link rel="stylesheet" href="/theme/css/custom-alabaster.css" />
		<!-- <link rel="stylesheet" href="/theme/fontawesome-free-6.5.1-web/css/all.min.css" /> -->
		<!--  <link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-brands-400.woff2" />
		<link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-regular-400.woff2" />
		<link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-solid-900.woff2" />
		<link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-v4compatibility.woff2" /> -->


	</head>
	<body class="no-sidebar">

		<!-- 内容 -->
		<div>

			<!-- Header Wrapper -->
			<div id="header-wrapper">
				<div class="container">
					<div class="row">
						<div class="12u">

							<!-- Header -->
								<section id="header">

									<!-- Logo -->
									<div class="page-home">
										<h1><a href="/">HOME</a></h1>
									</div>

									<!-- Nav -->
									<div class="page-menu">
										<nav id="nav">
											<ul>

												<!-- categories -->
														<li ><a href="/category/ai.html">AI</a></li>
														<li ><a href="/category/an-quan.html">安全</a></li>
														<li ><a href="/category/ban-ben-kong-zhi.html">版本控制</a></li>
														<li ><a href="/category/cao-zuo-xi-tong.html">操作系统</a></li>
														<li ><a href="/category/chang-yong-gong-ju-shi-yong.html">常用工具使用</a></li>
														<li ><a href="/category/da-shu-ju.html">大数据</a></li>
														<li><a href="/categories.html">More...</a></li>
											</ul>
										</nav>
									</div>
								</section>

						</div>
					</div>
					<div class="row page-head-search">
						<form class="navbar-search" action="/search.html" role="search">
							<!-- <button class="fa-solid fa-magnifying-glass" type="submit"></button> -->
							<button type="submit"></button>
							<input type="text" name="q" id="tipue_search_input" autocomplete="off" placeholder="Search...">
							<!-- <i class="fa-solid fa-magnifying-glass"></i> -->
						</form>
					</div>
  <div class="row page-head page-article persistent">
    <div class="page-head-title">
      <h2>Celery的Task</h2>
    </div>
    <div class="page-head-content">
      By
	  <a href="author/yanque.html">YanQue</a>
      , 20 二月 2023
      , Category:
	  <a href="category/hou-duan-python.html">后端; python</a>
    </div>
	<div class="red-line">
    </div>
  </div>
				</div>

				<!-- 头部下方动效 -->
				<div class="waves-area">
					<section class="main-hero-waves-area waves-area">
						<svg class="waves-svg" preserveAspectRatio="none" shape-rendering="auto" viewBox="0 24 150 28"
							 xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg">
							<defs>
								<path
										d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"
										id="gentle-wave"></path>
							</defs>
							<g class="parallax">
								<use href="#gentle-wave" x="48" y="0"></use>
								<use href="#gentle-wave" x="48" y="3"></use>
								<use href="#gentle-wave" x="48" y="5"></use>
								<use href="#gentle-wave" x="48" y="7"></use>
							</g>
						</svg>
					</section>
				</div>

			</div>

		<!-- Main Wrapper -->
			<div id="main-wrapper">
				<div class="container">
<div class="row">
	<div class="12u">
			<section>
				<div>
					<div class="row">
						<div class="12u skel-cell-mainContent">
							<!-- Content -->
								<article class="box is-post">
									<div class="box-head">
										<div class="post-infos">
											<ul class="tags">
												<li><a class="button" href="category/hou-duan-python.html">后端; python</a></li>
													<li><a class="button button-alt" href="tag/python.html">Python</a></li>

													<li><a class="button button-alt" href="tag/pythonsan-fang-ku.html">Python三方库</a></li>

													<li><a class="button button-alt" href="tag/celery_more.html">Celery_more</a></li>

											</ul>
										</div>

										<div class="pennant pennant-alt date">2023-02-20</div>
										<h2>Celery的Task</h2>

										<span class="head-modify-time">修改于: 2023-02-20</span>

									</div>
									<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">参考::</th><td class="field-body"><a class="reference external" href="https://www.celerycn.io/v/4.4.0/yong-hu-zhi-nan/ren-wu-tasks">[Celery 中文手册] 任务: Tasks</a></td>
</tr>
</tbody>
</table>
<p>概念与 异步 的任务类似</p>
<div class="section" id="section-1">
<h2>基础</h2>
<p>使用 task() 装饰器轻松的创建任何可被调用的任务:</p>
<pre class="literal-block">
from .models import User

&#64;app.task
def create_user(username, password):
    User.objects.create(username=username, password=password)
</pre>
<p>支持指定参数:</p>
<pre class="literal-block">
&#64;app.task(serializer='json')
def create_user(username, password):
    User.objects.create(username=username, password=password)
</pre>
<p>注意, 若存在多个装饰器, <tt class="docutils literal">app.task</tt> 需要放在首位.</p>
<p>还有一个 <tt class="docutils literal">app.shared_task</tt> 待...</p>
</div>
<div class="section" id="section-2">
<h2>一些属性/方法</h2>
<div class="section" id="app-task">
<h3>app.task装饰器支持的参数</h3>
<dl class="docutils">
<dt>name:</dt>
<dd><p class="first">任务注册的名称。</p>
<p class="last">可以手动设置任务名称，也可以通过模块名和类名进行自动生成(默认行为)。</p>
</dd>
<dt>backend:</dt>
<dd>结果后端的实例，用于任务结果后端，默认为 app.backend，可以通过 result_backend 进行配置。</dd>
<dt>acks_late:</dt>
<dd><p class="first">如果设置为 True，任务执行后（而不是执行前，默认为执行前）才会确认该任务的消息。</p>
<p class="last">注意：如果职程（Worker）执行过程中崩溃，任务可能会执行多次。
可以通过 task_acks_late 参数来进行全局配置。</p>
</dd>
<dt>track_started:</dt>
<dd><p class="first">如果设置为 True，当职程（Worker）执行任务时，任务状态为 stared。</p>
<p>默认为 False，因为在正常情况下是不需要该颗粒度级别的。
任务要么挂起、完成要么等待重试。
如果有长时间运行的任务，并且需要报告任当任务状态时，stared比较有用。</p>
<p>任务执行的职程（Worker）和进程 id 可以通过状态的元数据中进行查看（例如：result.info['pid']）。</p>
<p class="last">可以通过 task_track_started 进行全局配置。</p>
</dd>
<dt>rate_limit: Union[int, float, None]</dt>
<dd><p class="first">配置任务的频率.</p>
<p>限制指定任务类型的速率（限制在指定时间内运行的任务数量）。当速率限制生效时，任务仍然会完成，但是可能需要一些时间才能开始。</p>
<p>如果限制速率为 None，表示速率限制无效.</p>
<p class="last">速率可以为 int 也可以为 float 类型，则被表示为“每秒任务数”。</p>
</dd>
<dt>bind: bool=False</dt>
<dd>为 Trur 时表示设置第一个参数为 self (task实例)</dd>
<dt>serializer: str</dt>
<dd><p class="first">设置序列化方式, 会覆盖掉初始配置.</p>
<p class="last">默认为 task_serializer，
也可以为 pickle、json、yaml 或者通过 kombu.serialization.registry 注册的自定义序列化方法。</p>
</dd>
<dt>request:</dt>
<dd>如果该任务正处于执行状态，该信息包含该任务的请求信息。使用多线程本地存储。
见: <a class="reference internal" href="#request">request</a></dd>
<dt>throws: tuple</dt>
<dd>预期内的异常，如果在元组中含有该异常类，将不会被视为异常。 但是日志会记录到结果后端.</dd>
<dt>time_limit:</dt>
<dd>该任务的硬时间限制（以秒为单位），如果没有设置职程（Worker）时，使用默认值。</dd>
<dt>soft_time_limit:</dt>
<dd>该任务的软时间限制（以秒为单位），如果没有设置职程（Worker）时，使用默认值。</dd>
<dt>ignore_result:</dt>
<dd><p class="first">不存储任务状态信息，如果配置该选项 AsyncResult 将失效，无法进行检测任务情况以及返回内容。</p>
<p class="last">如果你并不关心任务的结果，请务必确定设置 ignore_result 选项，因为存储结果会浪费时间和资源。</p>
</dd>
<dt>store_errors_even_if_ignored:</dt>
<dd>如果设置为 True ，即使任务被忽略，也会存储错误信息。</dd>
<dt>compression:</dt>
<dd><p class="first">标识需要使用默认压缩方法的字符串。</p>
<p class="last">默认为 task_compression，可以设置为 gzip、bzip2或通过 kombu.compression 注册的自定义压缩方案。</p>
</dd>
<dt>max_retries: int = 3</dt>
<dd><p class="first">当前任务调用 self 或使用 autoretry_for 参数时才会启用。</p>
<p>如果重试的次数超过最大限制，会引发 MaxRetriesExceededError 异常。在异常时不会自动重试，所以必须手动调用 retry()。</p>
<p>默认值重试次数为3次，如果设置为 None 会关闭重试限制，直到任务执行成功为止。</p>
<p>速率限制也可以在数值后面添加 &quot;/s&quot;、&quot;/m&quot; 或 &quot;/h&quot;，以秒、分钟或以小时为单位。任务将在指定的时间内平均分配。</p>
<p>例如: &quot;100/m&quot; （每分钟100个任务）。则强制会在同一个职程（Worker）实例上启动俩个任务之间至少 600ms 的延迟。</p>
<p>默认值通过 task_default_rate_limit 进行设定：如果未指定，表示默认情况禁用任务的速率限制。</p>
<p class="last">注意，该速率限制为每一个职程（Worker）实例的限制，并非全局速率限制。配置全局速率限制（例如，API每秒最多请求的次数），必须制定队列。</p>
</dd>
<dt>default_retry_delay: Union[int, float] = 30 * 60</dt>
<dd>如果任务需要重试, 设置每次重试之间的间隔时间. 单位: 秒(s)</dd>
<dt>autoretry_for:</dt>
<dd><p class="first">任务失败时重试, 相关的配置.
异常类的列表或元组，如果任务在执行的过程中引发异常，任务将自动重试。默认情况下不会自动重试任何异常。</p>
<p class="last">见 <a class="reference internal" href="#autoretry-for">autoretry_for</a></p>
</dd>
<dt>retry_kwargs: dict</dt>
<dd><p class="first">任务失败重试时相关配置. 自定义配置自动重试参数。</p>
<p>注意，如果使用下面的 exponential backoff 选项是，
countdown 任务选项将由 Celery 的自动重试系统决定，字典中包含 countdown 会被忽略。</p>
<p class="last">见 <a class="reference internal" href="#retry-kwargs">retry_kwargs</a></p>
</dd>
<dt>retry_backoff: Union[int, bool] = False</dt>
<dd><p class="first">如果将此选项设置为True，则自动重试将按照 exponential backoff 规则延迟。
第一次重试延迟 1 秒，第二次重试延迟 2 秒，第三次延迟 4 秒，第四次延迟 8 秒，以此类推。
（如果启用了 retry_jitter 会修改延迟值）。</p>
<p>如果该选项设置为数字，则作为延迟因子.
例如，该选项设置为 3，那么第一次重试将延迟 3 秒，第二次将延迟 6 秒，第三次延迟 12 秒，第四次延迟 24秒，以此类推。</p>
<p class="last">默认情况下，该选项设置为 False，自动重试不会延迟。</p>
</dd>
<dt>retry_backoff_max: int = 600</dt>
<dd><p class="first">如果启动了 retry_backoff，该选项在任务自动重试之间设置以秒为单位的最大延迟。</p>
<p class="last">默认情况，该选项默认值为 600，即 10分钟。</p>
</dd>
<dt>retry_jitter: bool = True</dt>
<dd><p class="first">Jitter 用于随机性引入指数回退延迟，防止队列中所有任务同时执行.</p>
<p class="last">如果该选项设置为 True，则将 retry_backoff 计算的延迟作为最大值，实际的延迟值为一个介于 0 和最大值之间的一个随机数。</p>
</dd>
</dl>
</div>
<div class="section" id="retry">
<h3>retry</h3>
<p>任务失败时的重试</p>
<p>当调用 retry 时，会发送与原始任务相同的ID发送一条消息，将该消息发送到原始任务的对列中。
当任务被重试时，也会被记录为一个任务状态，便于通过 result 实例来跟踪任务。</p>
<p>例:</p>
<pre class="literal-block">
&#64;app.task(bind=True)
def send_twitter_status(self, oauth, tweet):
    try:
        twitter = Twitter(oauth)
        twitter.update_status(tweet)
    except (Twitter.FailWhaleError, Twitter.LoginError) as exc:
        raise self.retry(exc=exc)
</pre>
<p>exc 参数主要用传递日志和存储任务结果时的使用的异常信息。exception 和 traceback 都将在任务状态中可用(如果启用了结果后端)。</p>
<p>任务如果有一个 max_retries 值，超出了重试的最大次数，则会重新引发当前的异常信息，但如果:</p>
<ul>
<li><p class="first">exc 参数没有设置
该情况会引发 MaxRetriesExceededError 异常</p>
</li>
<li><p class="first">没有异常
如果没有初始异常来重新引发exc参数，可以使用:</p>
<pre class="literal-block">
self.retry(exc=Twitter.LoginError())
</pre>
<p>设置 exc 参数值</p>
</li>
</ul>
</div>
<div class="section" id="request">
<h3>request</h3>
<p><a class="reference external" href="https://www.celerycn.io/v/4.4.0/yong-hu-zhi-nan/ren-wu-tasks/ren-wu-qing-qiu-task-request">任务请求：Task Request</a></p>
<p>app.Task.request 包含与当前执行任务相关的信息和状态。
该请求定义了以下属性:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">属性名称</th>
<th class="head">说明</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>id</td>
<td>执行任务的唯一ID</td>
</tr>
<tr><td>group</td>
<td>任务组的唯一ID（该任务是组成员的情况下）</td>
</tr>
<tr><td>chord</td>
<td>此任务所属的和弦的惟一id(如果该任务是标题的一部分)</td>
</tr>
<tr><td>correlation_id</td>
<td>用于重复数据删除的自定义ID</td>
</tr>
<tr><td>args</td>
<td>选项参数</td>
</tr>
<tr><td>kwargs</td>
<td>关键字参数</td>
</tr>
<tr><td>origin</td>
<td>发送任务的主机名</td>
</tr>
<tr><td>retries</td>
<td>任务重试次数，默认是从 0 开始的</td>
</tr>
<tr><td>is_eager</td>
<td>如果任务是由客户端执行，并非职程（Worker）执行，设置 True</td>
</tr>
<tr><td>expires</td>
<td>任务预计时间（如果已经设置的情况下），时间为 UTC 格式（取决于 enable_utc 设置）</td>
</tr>
<tr><td>hostname</td>
<td>执行任务的职程（Worker）实例的节点名</td>
</tr>
<tr><td>delivery_info</td>
<td>添加附加传递消息，主要用于包含交付任务的交换和路由键的映射，retry() 主要用于重新讲任务下发到队列中，该 dict 中的键可用取决于使用的消息中间人（Broker）。</td>
</tr>
<tr><td>reply-to</td>
<td>回复的发送的队列名称（例如，与 RPC 结果后端一起使用）</td>
</tr>
<tr><td>called_directly</td>
<td>如果职程（Worker）未执行任务，则此标志设置为true</td>
</tr>
<tr><td>timelimit</td>
<td>当前(软、硬)时间限制的元组(如果有的话)</td>
</tr>
<tr><td>callbacks</td>
<td>如果此任务成功返回，将调用的签名列表</td>
</tr>
<tr><td>errback</td>
<td>如果此任务失败，将调用的签名列表</td>
</tr>
<tr><td>utc</td>
<td>设置为 true ，启用 UTC</td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>headers</td>
<td>与任务消息一起发送的消息头的映射（可以为 None）</td>
</tr>
<tr><td>reply_to</td>
<td>回复的地址（队列名称）</td>
</tr>
<tr><td>correlation_id</td>
<td>一般与任务的ID相同，通常用于AMQP中跟踪回复的内容</td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>root_id</td>
<td>此任务所属工作流中的第一个任务的唯一ID（如果有）</td>
</tr>
<tr><td>parent_id</td>
<td>调用此任务的任务的惟一id（如果有）</td>
</tr>
<tr><td>chain</td>
<td>反转形成链的任务列表（如果有）。列表中最后一个任务是当前任务执行成功之后的下一个任务。如果使用任务协议的第一个版本，则链任务将位于 request.callbacks 中</td>
</tr>
</tbody>
</table>
<p>案例
访问上下文访问信息的一个任务案例:</p>
<pre class="literal-block">
&#64;app.task(bind=True)
def dump_context(self, x, y):
    print('Executing task id {0.id}, args: {0.args!r} kwargs: {0.kwargs!r}'.format(
            self.request))
</pre>
<p>bind 参数表示该函数绑是一个绑定方法，可以通过访问任务类型实例中的属性和方法。</p>
</div>
</div>
<div class="section" id="section-3">
<h2>任务重试</h2>
<div class="section" id="section-4">
<h3>使用装饰器参数的方式</h3>
<p id="autoretry-for">有时，您只想在引发特定异常时重试任务。 可也通过 Celery 中 task() 装饰器中的 autoretry_for 参数进行自动重试任务:</p>
<pre class="literal-block">
from twitter.exceptions import FailWhaleError

&#64;app.task(autoretry_for=(FailWhaleError,))
def refresh_timeline(user):
    return twitter.refresh_timeline(user)
</pre>
<p id="retry-kwargs">可以通过 task() 中的 retry_kwargs 参数来指定 retry() 内部调用参数:</p>
<pre class="literal-block">
&#64;app.task(autoretry_for=(FailWhaleError,),
          retry_kwargs={'max_retries': 5})
def refresh_timeline(user):
    return twitter.refresh_timeline(user)
</pre>
<p>上面的示例与在 try ... except 语句中包含的代码块使用 <a class="reference internal" href="#retry">retry</a> 效果一致:</p>
<pre class="literal-block">
&#64;app.task
def refresh_timeline(user):
    try:
        twitter.refresh_timeline(user)
    except FailWhaleError as exc:
        raise div.retry(exc=exc, max_retries=5)
</pre>
<p>如果你想自动重试任何错误，只需使用:</p>
<pre class="literal-block">
&#64;app.task(autoretry_for=(Exception,))
def x():
    ...
</pre>
</div>
<div class="section" id="section-5">
<h3>手动捕获的方式</h3>
<p>见 <a class="reference internal" href="#retry">retry</a></p>
</div>
</div>
<div class="section" id="section-6">
<h2>任务状态</h2>
<div class="section" id="section-7">
<h3>内置状态</h3>
<dl class="docutils">
<dt>PENDING</dt>
<dd>任务正在等待执行或未知。任何未知的任务 ID 都默认处于挂起状态。</dd>
<dt>STARTED</dt>
<dd><p class="first">任务已经开始。默认情况下不会记录，需要启用，请参阅 app.Task.track_started.。</p>
<p class="last">meta-data：正在执行任务的职程（Worker） pid 和主机名。</p>
</dd>
<dt>SUCCESS</dt>
<dd><p class="first">任务执行成功。</p>
<p class="last">meta-data：任务结果返回值 propagates：Yes ready: Yes</p>
</dd>
<dt>FAILURE</dt>
<dd>任务执行失败。
meta-data：执行异常时的任务信息，其中 traceback 包含引发错误的堆栈信息。 propagates：Yes</dd>
<dt>RETRY</dt>
<dd><p class="first">任务处于重试状态。</p>
<p class="last">meta-data：结果信息包含导致重试的异常信息，traceback 包含引发异常时堆栈的回溯。 propagates：No</p>
</dd>
<dt>REVOKED</dt>
<dd><p class="first">任务被撤销。</p>
<p class="last">propagates：Yes</p>
</dd>
</dl>
</div>
<div class="section" id="section-8">
<h3>自定义状态</h3>
<p><strong>使用 update_state() 更新任务状态</strong></p>
<p>只需要设置一个位置的名称，就可以轻松的自定义状态，状态名通常是大写的字符串。</p>
<p>例如，您可以查看定义自定义中止状态的可中止任务:</p>
<pre class="literal-block">
&#64;app.task(bind=True)
def upload_files(self, filenames):
    for i, file in enumerate(filenames):
        if not self.request.called_directly:
            self.update_state(state='PROGRESS',
                meta={'current': i, 'total': len(filenames)})
</pre>
<p>在这里，创建了一个名称为“ PROGRESS”的状态，通过 current 和 total 作为元数据的一部分，
计算任务当前正在进行状态的任何应用程序以及任务在进程中位置。可以通过该方法来创建任务进度条。</p>
</div>
</div>
<div class="section" id="section-9">
<h2>自定义任务类</h2>
<p>所有的任务都继承 app.Task 类，run() 方法为任务体。
例如:</p>
<pre class="literal-block">
&#64;app.task
def add(x, y):
    return x + y
</pre>
<p>在内部大概会是这样:</p>
<pre class="literal-block">
class _AddTask(app.Task):

    def run(self, x, y):
        return x + y
add = app.tasks[_AddTask.name]
</pre>
</div>
<div class="section" id="section-10">
<h2>任务调用</h2>
<ul class="simple">
<li><a class="reference internal" href="#apply-async">apply_async</a> , 发送一个任务消息</li>
<li><a class="reference internal" href="#delay">delay</a> ,       直接发送一个任务消息,但是不支持运行参数</li>
<li><a class="reference internal" href="#calling">calling</a> ,     应用一个支持调用接口（例如，add(2,2)）的对象,
意味着任务不会被一个 worker 执行,但是会在当前线程中执行(但是消息不会被发送)</li>
</ul>
<div class="section" id="apply-async">
<h3>apply_async</h3>
<div class="rst-function section" id="apply_async(args[, kwargs[, ...]])">
<strong>apply_async(args[, kwargs[, ...]])</strong><p></p>
<p>发送一个任务消息。</p>
<p>T.apply_async((arg,), {'kwarg': value})</p>
<p>从现在起, 十秒内执行:</p>
<pre class="literal-block">
T.apply_async(countdown=10)
</pre>
<p>从现在起十秒内执行，指明使用eta:</p>
<pre class="literal-block">
T.apply_async(eta=now + timedelta(seconds=10))
</pre>
<p>从现在起一分钟执行，但在两分钟后过期:</p>
<pre class="literal-block">
T.apply_async(countdown=60, expires=120)
</pre>
<p>两天内过期，使用datetime对象:</p>
<pre class="literal-block">
T.apply_async(expires=now + timedelta(days=2))
</pre>
<p>一些位置参数:</p>
<dl class="docutils">
<dt>link: Union[Callable, list]</dt>
<dd><p class="first">Celery支持任务链，一个任务在另一个任务之后。回调任务将用父任务的结果作为一部分参数:</p>
<pre class="last literal-block">
res = add.apply_async((2, 2), link=add.s(16))

# 译者注
# res.get() --&gt; 4 # 2+2 = 4
# res.children[0].get() --&gt; 20 # 4 + 16
</pre>
</dd>
<dt>link_error: Union[Callable, list]</dt>
<dd><p class="first">添加错误回调签名</p>
<p>例子:</p>
<pre class="literal-block">
&#64;app.task
def error_handler(uuid):
    result = AsyncResult(uuid)
    exc = result.get(propagate=False)
    print('Task {0} raised exception: {1!r}\n{2!r}'.format(
          uuid, exc, result.traceback))
</pre>
<p>可以使用 link_error 执行选项将其添加到任务中:</p>
<pre class="literal-block">
add.apply_async((2, 2), link_error=error_handler.s())
</pre>
<p>此外，link 和 link_error 选项都可以是list:</p>
<pre class="literal-block">
add.apply_async((2, 2), link=[add.s(16), other_task.s()])
</pre>
<p class="last">然后将依次调用回调/错误返回，并且将使用父任务的返回值作为部分参数来调用所有回调</p>
</dd>
<dt>countdown: int</dt>
<dd>在某个时间之前结束, 见 <a class="reference internal" href="#countdown">countdown</a></dd>
<dt>eta: datatime</dt>
<dd>在某个时间之前结束, 见 <a class="reference internal" href="#eta">eta</a></dd>
<dt>expires: Union[int, datetime]</dt>
<dd>任务有效期, 与上基本一致, 见 <a class="reference internal" href="#expires">expires</a></dd>
<dt>retry: bool = True</dt>
<dd>是否失败重试, 对应配置为: task_publish_retry</dd>
<dt>retry_policy: dict</dt>
<dd><p class="first">重试策略, 对应配置为: task_publish_retry_policy.</p>
<p>支持的键为:</p>
<dl class="docutils">
<dt>max_retries: int = 3</dt>
<dd><p class="first">最大重试次数，在这种情况下，将抛出重试失败的异常。</p>
<p class="last">值为None意味着它将永远重试。</p>
</dd>
<dt>interval_start: int = 0</dt>
<dd>定义两次重试之间要等待的秒数（浮点数或整数）。默认值为0（第一次重试是瞬时的）。</dd>
<dt>interval_step: float = 0.2</dt>
<dd>在每次连续重试时，此数字将被添加到重试延迟中（浮点数或整数）。默认值为0.2。</dd>
<dt>interval_max: float=0.2</dt>
<dd>重试之间等待的最大秒数（浮点数或整数）。默认值为0.2。</dd>
</dl>
<p>例:</p>
<pre class="literal-block">
add.apply_async((2, 2), retry=True, retry_policy={
    'max_retries': 3,
    'interval_start': 0,
    'interval_step': 0.2,
    'interval_max': 0.2,
})
</pre>
<p class="last">重试的最长时间为0.4秒。
默认情况下将其设置为相对较短，因为如果代理连接断开，连接失败可能导致重试堆效应–
例如，许多 Web 服务器进程正在等待重试，从而阻止了其他传入请求。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="delay">
<h3>delay</h3>
<div class="rst-function section" id="delay(*args, **kwargs)">
<strong>delay(*args, **kwargs)</strong><p></p>
<p>直接发送一个任务消息,但是不支持运行参数。</p>
<p><tt class="docutils literal">T.delay(arg, kwarg=value)</tt> 调用 apply_async 的快捷方式:</p>
<pre class="literal-block">
.delay(_args, *_kwargs)
</pre>
<p>等价于调用:</p>
<pre class="literal-block">
.apply_async(args, kwargs)
</pre>
<p>例如, delay 版:</p>
<pre class="literal-block">
task.delay(arg1, arg2, kwarg1='x', kwarg2='y')
</pre>
<p>apply_async版:</p>
<pre class="literal-block">
task.apply_async(args=[arg1, arg2], kwargs={'kwarg1': 'x', 'kwarg2': 'y'})
</pre>
<p>尽管运行十分方便，但是如果像设置额外的行参数，必须用 <a class="reference internal" href="#apply-async">apply_async</a></p>
</div>
</div>
<div class="section" id="calling">
<h3>calling</h3>
<div class="rst-function section" id="calling(__call__)">
<strong>calling(__call__)</strong><p></p>
<p>应用一个支持调用接口（例如，add(2,2)）的对象,意味着任务不会被一个 worker 执行,但是会在当前线程中执行(但是消息不会被发送)。</p>
</div>
</div>
</div>
<div class="section" id="section-11">
<h2>任务回调</h2>
<p>task支持的函数回调</p>
<ul class="simple">
<li><a class="reference internal" href="#after-return">after_return</a>  任务返回后调用的处理程序</li>
<li><a class="reference internal" href="#on-failure">on_failure</a>    任务执行失败时，由职程（Worker）调用。</li>
<li><a class="reference internal" href="#on-retry">on_retry</a>      任务重试时，由职程（Worker）调用。</li>
<li><a class="reference internal" href="#on-success">on_success</a>    任务成功时，由职程（Worker）调用。</li>
</ul>
<div class="section" id="after-return">
<h3>after_return</h3>
<div class="rst-function section" id="after_return(self, status, retval, task_id, args, kwargs, einfo)">
<strong>after_return(self, status, retval, task_id, args, kwargs, einfo)</strong><p></p>
<p>任务返回后调用的处理程序</p>
<p>位置参数:</p>
<pre class="literal-block">
status  – 当前任务状态
retval  – 任务返回值/异常
task_id – 唯一的任务ID
args    – 返回任务的原始参数
kwargs  – 返回任务的原始关键字
</pre>
<p>关键字参数:</p>
<pre class="literal-block">
einfo   – 异常信息实例，包含 traceback （有的情况下）
</pre>
<p>此处理程序的返回值将被忽略。</p>
</div>
</div>
<div class="section" id="on-failure">
<h3>on_failure</h3>
<div class="rst-function section" id="on_failure(self, exc, task_id, args, kwargs, einfo)">
<strong>on_failure(self, exc, task_id, args, kwargs, einfo)</strong><p></p>
<p>任务执行失败时，由职程（Worker）调用。</p>
<p>位置参数:</p>
<pre class="literal-block">
exc     – 任务引发的异常。
task_id – 执行失败任务的唯一 ID。
args    – 任务失败的原始参数。
kwargs  – 任务失败的原始关键字。
</pre>
<p>关键字参数:</p>
<pre class="literal-block">
einfo   – 异常信息实例，包含 traceback （有的情况下）。
</pre>
<p>此处理程序的返回值将被忽略。</p>
</div>
</div>
<div class="section" id="on-retry">
<h3>on_retry</h3>
<div class="rst-function section" id="on_retry(self, exc, task_id, args, kwargs, einfo)">
<strong>on_retry(self, exc, task_id, args, kwargs, einfo)</strong><p></p>
<p>任务重试时，由职程（Worker）调用。</p>
<p>位置参数:</p>
<pre class="literal-block">
exc     – 发送给 retry() 函数的异常
task_id – 任务重试唯一 ID。
args    – 任务重试的原始参数。
kwargs  – 任务重试的原始关键字。 Keyword Arguments:
einfo   – 异常信息实例，包含 traceback （有的情况下）。
</pre>
<p>此处理程序的返回值将被忽略。</p>
</div>
</div>
<div class="section" id="on-success">
<h3>on_success</h3>
<div class="rst-function section" id="on_success(self, retval, task_id, args, kwargs)">
<strong>on_success(self, retval, task_id, args, kwargs)</strong><p></p>
<p>任务成功时，由职程（Worker）调用。</p>
<p>位置参数:</p>
<pre class="literal-block">
retval  – 任务的返回值
task_id – 执行成功唯一 ID。
args    – 任务执行成功时的原始参数。
kwargs  – 任务执行成功时的原始关键字。
</pre>
<p>此处理程序的返回值将被忽略。</p>
</div>
</div>
</div>
<div class="section" id="on-message">
<h2>获取回调改变/状态-on_message</h2>
<p>Celery 可以通过消息回调获取所有状态的改变。例如对于长时任务发送人任务进程，你可以这样做:</p>
<pre class="literal-block">
&#64;app.task(bind=True)
def hello(self, a, b):
    time.sleep(1)
    self.update_state(state=&quot;PROGRESS&quot;, meta={'progress': 50})
    time.sleep(1)
    self.update_state(state=&quot;PROGRESS&quot;, meta={'progress': 90})
    time.sleep(1)
    return 'hello world: %i' % (a+b)

def on_raw_message(body):
    print(body)

r = hello.apply_async(4, 6)
print(r.get(on_message=on_raw_message, propagate=False))
</pre>
<p>将生成如下输出:</p>
<pre class="literal-block">
{'task_id': '5660d3a3-92b8-40df-8ccc-33a5d1d680d7',
'result': {'progress': 50},
'children': [],
'status': 'PROGRESS',
'traceback': None}
{'task_id': '5660d3a3-92b8-40df-8ccc-33a5d1d680d7',
'result': {'progress': 90},
'children': [],
'status': 'PROGRESS',
'traceback': None}
{'task_id': '5660d3a3-92b8-40df-8ccc-33a5d1d680d7',
'result': 'hello world: 10',
'children': [],
'status': 'SUCCESS',
'traceback': None}
hello world: 10
</pre>
</div>
<div class="section" id="eta-and-countdown">
<h2>限制时间-ETA and Countdown</h2>
<p id="eta"><strong>ETA</strong> (estimated time of arrival, 预计到底时间) 让你设置一个日期和时间，在这个时间之前任务将被执行。</p>
<p id="countdown"><strong>countdown</strong> 是一种以秒为单位设置ETA的快捷方式:</p>
<pre class="literal-block">
&gt;&gt;&gt; result = add.apply_async((2, 2), countdown=3)
&gt;&gt;&gt; result.get()    # this takes at least 3 seconds to return
20
</pre>
<p>确保任务在指定的日期和时间之后的某个时间执行，但不一定在该时间执行。
可能原因可能包括许多项目在队列中等待，或者严重的网络延迟。为了确保您的任务及时执行，你应该监视队列中的拥塞情况。
使用Munin或类似工具来接收警报，因此可以采取适当的措施来减轻负载。点击查看Munin。</p>
<p>尽管 countdown 是整数，但eta必须是一个 datetime 对象，并指定确切的日期和时间（包括毫秒精度和时区信息）:</p>
<pre class="literal-block">
&gt;&gt;&gt; from datetime import datetime, timedelta

&gt;&gt;&gt; tomorrow = datetime.utcnow() + timedelta(days=1)
&gt;&gt;&gt; add.apply_async((2, 2), eta=tomorrow)
</pre>
<p id="expires"><strong>expries</strong> 参数定义了一个可选的到期时间，既可以作为任务之后秒发布，或在特定日期和时间使用 datetime:</p>
<pre class="literal-block">
&gt;&gt;&gt; # Task expires after one minute from now.
&gt;&gt;&gt; add.apply_async((10, 10), expires=60)

&gt;&gt;&gt; # Also supports datetime
&gt;&gt;&gt; from datetime import datetime, timedelta
&gt;&gt;&gt; add.apply_async((10, 10), kwargs,
...                 expires=datetime.now() + timedelta(days=1)
</pre>
<p>当 worker 收到过期的任务时，它将任务标记为REVOKED</p>
</div>
<div class="section" id="section-12">
<h2>创建连接池</h2>
<p>自动池支持</p>
<p>从2.3版开始，支持自动连接池，因此您不必手动处理连接和发布者即可重用连接。</p>
<p>从2.5版开始，默认情况下启用连接池。</p>
<p>您可以通过创建发布者来手动处理连接:</p>
<pre class="literal-block">
results = []
with add.app.pool.acquire(block=True) as connection:
    with add.get_publisher(connection) as publisher:
        try:
            for args in numbers:
                res = add.apply_async((2, 2), publisher=publisher)
                results.append(res)
print([res.get() for res in results])
</pre>
<p>尽管这是个特定示例，但是可以更好的展现一组:</p>
<pre class="literal-block">
&gt;&gt;&gt; from celery import group

&gt;&gt;&gt; numbers = [(2, 2), (4, 4), (8, 8), (16, 16)]
&gt;&gt;&gt; res = group(add.s(i, j) for i, j in numbers).apply_async()

&gt;&gt;&gt; res.get()
[4, 8, 16, 32]
</pre>
</div>

								</article>
						</div>
					</div>
				</div>
			</section>
	</div>
</div>

				</div>
			</div>



		<!-- Sider Bar -->
		<div id="right-side-bar">
	<nav>
		<div id="top-toc-tree-container" class="fixed-container">
			<div class="toc-contents-title">
				<h4 id="toc-contents-title-text">Contents</h4>
				<!-- <span class="tool-tip-text">点击隐藏</span> -->
			</div>
			<div id="toc-tree-container">
 <ul class="toc-tree visible">
  <li class="toc-h0">
   <a class="" href="#section-1">
    基础
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-2">
    一些属性/方法
   </a>
   <ul class="toc-tree visible">
    <li class="toc-h1">
     <a class="" href="#app-task">
      app.task装饰器支持的参数
     </a>
    </li>
    <li class="toc-h1">
     <a class="" href="#retry">
      retry
     </a>
    </li>
    <li class="toc-h1">
     <a class="" href="#request">
      request
     </a>
    </li>
   </ul>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-3">
    任务重试
   </a>
   <ul class="toc-tree visible">
    <li class="toc-h1">
     <a class="" href="#section-4">
      使用装饰器参数的方式
     </a>
    </li>
    <li class="toc-h1">
     <a class="" href="#section-5">
      手动捕获的方式
     </a>
    </li>
   </ul>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-6">
    任务状态
   </a>
   <ul class="toc-tree visible">
    <li class="toc-h1">
     <a class="" href="#section-7">
      内置状态
     </a>
    </li>
    <li class="toc-h1">
     <a class="" href="#section-8">
      自定义状态
     </a>
    </li>
   </ul>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-9">
    自定义任务类
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-10">
    任务调用
   </a>
   <ul class="toc-tree visible">
    <li class="toc-h1">
     <a class="" href="#apply-async">
      apply_async
     </a>
     <ul class="toc-tree visible">
      <li class="toc-h2">
       <a class="" href="#apply_async(args[, kwargs[, ...]])">
       </a>
      </li>
     </ul>
    </li>
    <li class="toc-h1">
     <a class="" href="#delay">
      delay
     </a>
     <ul class="toc-tree visible">
      <li class="toc-h2">
       <a class="" href="#delay(*args, **kwargs)">
       </a>
      </li>
     </ul>
    </li>
    <li class="toc-h1">
     <a class="" href="#calling">
      calling
     </a>
     <ul class="toc-tree visible">
      <li class="toc-h2">
       <a class="" href="#calling(__call__)">
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-11">
    任务回调
   </a>
   <ul class="toc-tree visible">
    <li class="toc-h1">
     <a class="" href="#after-return">
      after_return
     </a>
     <ul class="toc-tree visible">
      <li class="toc-h2">
       <a class="" href="#after_return(self, status, retval, task_id, args, kwargs, einfo)">
       </a>
      </li>
     </ul>
    </li>
    <li class="toc-h1">
     <a class="" href="#on-failure">
      on_failure
     </a>
     <ul class="toc-tree visible">
      <li class="toc-h2">
       <a class="" href="#on_failure(self, exc, task_id, args, kwargs, einfo)">
       </a>
      </li>
     </ul>
    </li>
    <li class="toc-h1">
     <a class="" href="#on-retry">
      on_retry
     </a>
     <ul class="toc-tree visible">
      <li class="toc-h2">
       <a class="" href="#on_retry(self, exc, task_id, args, kwargs, einfo)">
       </a>
      </li>
     </ul>
    </li>
    <li class="toc-h1">
     <a class="" href="#on-success">
      on_success
     </a>
     <ul class="toc-tree visible">
      <li class="toc-h2">
       <a class="" href="#on_success(self, retval, task_id, args, kwargs)">
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li class="toc-h0">
   <a class="" href="#on-message">
    获取回调改变/状态-on_message
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#eta-and-countdown">
    限制时间-ETA and Countdown
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-12">
    创建连接池
   </a>
  </li>
 </ul>
</div>

		</div>
	</nav>
	<div id="sidebar-tools" class="fixed-container no-active cant-select">
		<!-- 按钮 使用 content 绘制图标 -->
	</div>
	<div id="sidebar-tool-back-top" class="fixed-container cant-select">
		<!-- 按钮 使用 content 绘制图标 -->
	</div>
		</div>

		<!-- Footer Wrapper -->
			<div id="footer-wrapper">
				<!-- Footer -->
					<section id="footer" class="container">
						<div class="row">
							<div class="8u">
								<section>
									<header>
										<h2>Latest articles</h2>
									</header>
									<ul class="dates">
										<li>
											<span class="date"> 7 <strong>30</strong></span>
											<h3><a href="yq-docs-front-end-tutorial-Package.json-configuration-instructions.html">package.json配置说明</a></h3>
											<p><p class="first last">package.json配置说明</p>
</p>
										</li>
										<li>
											<span class="date"> 7 <strong>30</strong></span>
											<h3><a href="yq-docs-front-end-tutorial-npm-add-private-git-repo.html">npm包增加私有git库</a></h3>
											<p><p class="first last">npm包增加私有git库</p>
</p>
										</li>
										<li>
											<span class="date"> 7 <strong>29</strong></span>
											<h3><a href="yq-docs-front-end-CSS-calculation-of-values.html">值的计算方式(函数)</a></h3>
											<p><p class="first last">值的计算方式(函数)</p>
</p>
										</li>
										<li>
											<span class="date"> 7 <strong>24</strong></span>
											<h3><a href="yq-docs-front-end-node-Three--party-library-chalk.html">chalk</a></h3>
											<p><p class="first last">chalk</p>
</p>
										</li>
									</ul>
								</section>
							</div>
						</div>
						<div class="row">
							<div class="4u">
								<section>
									<header>
										<h2>Blogroll</h2>
									</header>
									<ul class="divided">
											<li><a href="https://yq-yqr.readthedocs.io/zh/blog-theme/blog.html">旧版(迁移中)</a></li>
											<li><a href="https://getpelican.com/">Pelican</a></li>
											<li><a href="https://www.python.org/">Python.org</a></li>
											<li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
									</ul>
								</section>
							</div>
							<div class="4u">
								<section>
									<header>
										<h2>Categories</h2>
									</header>
									<ul class="divided">
											<li><a href="/category/ai.html">AI</a></li>
											<li><a href="/category/an-quan.html">安全</a></li>
											<li><a href="/category/ban-ben-kong-zhi.html">版本控制</a></li>
											<li><a href="/category/cao-zuo-xi-tong.html">操作系统</a></li>
									</ul>
								</section>
							</div>

							<div class="4u">
								<section>
									<header>
										<h2>SITEMAP</h2>
									</header>

									<ul class="divided">
												<li><a href="/authors.html">作者</a></li>
												<li><a href="/categories.html">分类</a></li>
												<li><a href="/archives.html">归档</a></li>
												<li><a href="/tags.html">标签</a></li>
									</ul>
								</section>
							</div>

							<div class="4u">

								<section>
									<header>
										<h2>Contact</h2>
									</header>
									<ul class="social">
									</ul>
								</section>
							</div>
						</div>
						<div class="row">
							<div class="12u">
								<!-- Copyright -->
									<div id="copyright">
										<ul class="links">
											<li>&copy; YanQue 2021-2024	</li>
											<!-- <li>Images: <a href="http://facebook.com/DreametryDoodle">Dreametry Doodle</a> + <a href="http://iconify.it">Iconify.it</a></li>
											<li>Design: <a href="http://html5up.net">HTML5 UP</a></li> -->
										</ul>
									</div>
							</div>
						</div>
					</section>
			</div>

		</div>

		<!-- 其他 -->

			<div style="position: fixed;">
				<!-- 深色模式粒子效果 -->
				<!-- <canvas id="universe" width="1428" height="993" data-relingo-block="true" data-relingo-parsed="true"></canvas> -->
				<!-- 深色模式下添加粒子效果canvas -->
				<canvas id="universe" width="1312" height="880"></canvas>
			</div>

		<script src="/theme/js/jquery-3.7.1.min.js"></script>
		<script src="/theme/js/jquery.dropotron.js"></script>
		<script src="/theme/js/config.js"></script>
		<script src="/theme/skel-s0.4.8/skel.min.js"></script>
		<script src="/theme/skel-s0.4.8/skel-panels.min.js"></script>
		<!-- <script src="/theme/js/skel.min.js"></script>
		<script src="/theme/js/skel-panels.min.js"></script> -->
		<script src="/theme/js/backloading.js"></script>
		<script src="/theme/js/canvas/dark.js"></script>
<script type="text/javascript">
	function addEvent() {
		$("#toc-contents-title-text").click(function() {
			$("#top-toc-tree-container").toggleClass("no-active");
			$("#sidebar-tools").toggleClass("no-active");
		})
		$("#sidebar-tools").click(function() {
			$("#top-toc-tree-container").toggleClass("no-active");
			$("#sidebar-tools").toggleClass("no-active");
		})
		$("#sidebar-tool-back-top").click(function() {
			// window.scrollTo(0, 0);
			window.scrollTo({
				top: 0,
				left: 0,
				behavior: 'smooth'
			});
		})
	}
	addEvent()
</script>
		<!--[if lte IE 8]><script src="js/html5shiv.js"></script><link rel="stylesheet" href="/theme/css/ie8.css" /><![endif]-->
	</body>
</html>