
<!DOCTYPE HTML>
<!--
	Dopetrope 2.0 by HTML5 UP
	html5up.net | @n33co
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html data-theme="dark">
	<head>
			<title>书言</title>
			<meta http-equiv="content-type" content="text/html; charset=utf-8" />
			<meta charset="utf-8" />

			<!-- <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,900,300italic" rel="stylesheet" /> -->
			<link rel="stylesheet" href="/theme/css/custom-pygment.css" />
			<noscript>
				<link rel="stylesheet" href="/theme/css/skel-noscript.css" />
				<link rel="stylesheet" href="/theme/css/style.css" />
				<link rel="stylesheet" href="/theme/css/style-desktop.css" />
			</noscript>

		<!-- tipuesearch 放在这, 因为搜索框是全局定义的 -->
		<link rel="stylesheet" href="/theme//Tipue-Search-5.0.0/tipuesearch.css" />
		<link rel="stylesheet" href="/theme//Tipue-Search-5.0.0/custom/tipuesearch-custom.css" />
		<link rel="stylesheet" href="/theme/css/alabaster.css" />
		<link rel="stylesheet" href="/theme/css/custom-alabaster.css" />
		<!-- <link rel="stylesheet" href="/theme/fontawesome-free-6.5.1-web/css/all.min.css" /> -->
		<!--  <link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-brands-400.woff2" />
		<link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-regular-400.woff2" />
		<link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-solid-900.woff2" />
		<link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-v4compatibility.woff2" /> -->


	</head>
	<body class="no-sidebar">

		<!-- 内容 -->
		<div>

			<!-- Header Wrapper -->
			<div id="header-wrapper">
				<div class="container">
					<div class="row">
						<div class="12u">

							<!-- Header -->
								<section id="header">

									<!-- Logo -->
									<div class="page-home">
										<h1><a href="/">HOME</a></h1>
									</div>

									<!-- Nav -->
									<div class="page-menu">
										<nav id="nav">
											<ul>

												<!-- categories -->
														<li ><a href="/category/ai.html">AI</a></li>
														<li ><a href="/category/an-quan.html">安全</a></li>
														<li ><a href="/category/ban-ben-kong-zhi.html">版本控制</a></li>
														<li ><a href="/category/cao-zuo-xi-tong.html">操作系统</a></li>
														<li ><a href="/category/chang-yong-gong-ju-shi-yong.html">常用工具使用</a></li>
														<li ><a href="/category/da-shu-ju.html">大数据</a></li>
														<li><a href="/categories.html">More...</a></li>
											</ul>
										</nav>
									</div>
								</section>

						</div>
					</div>
					<div class="row page-head-search">
						<form class="navbar-search" action="/search.html" role="search">
							<!-- <button class="fa-solid fa-magnifying-glass" type="submit"></button> -->
							<button type="submit"></button>
							<input type="text" name="q" id="tipue_search_input" autocomplete="off" placeholder="Search...">
							<!-- <i class="fa-solid fa-magnifying-glass"></i> -->
						</form>
					</div>
  <div class="row page-head page-article persistent">
    <div class="page-head-title">
      <h2>HTTP认识</h2>
    </div>
    <div class="page-head-content">
      By
	  <a href="author/yanque.html">YanQue</a>
      , 09 March 2024
      , Category:
	  <a href="category/ji-suan-ji-wang-luo.html">计算机网络</a>
    </div>
	<div class="red-line">
    </div>
  </div>
				</div>

				<!-- 头部下方动效 -->
				<div class="waves-area">
					<section class="main-hero-waves-area waves-area">
						<svg class="waves-svg" preserveAspectRatio="none" shape-rendering="auto" viewBox="0 24 150 28"
							 xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg">
							<defs>
								<path
										d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"
										id="gentle-wave"></path>
							</defs>
							<g class="parallax">
								<use href="#gentle-wave" x="48" y="0"></use>
								<use href="#gentle-wave" x="48" y="3"></use>
								<use href="#gentle-wave" x="48" y="5"></use>
								<use href="#gentle-wave" x="48" y="7"></use>
							</g>
						</svg>
					</section>
				</div>

			</div>

		<!-- Main Wrapper -->
			<div id="main-wrapper">
				<div class="container">
<div class="row">
	<div class="12u">
			<section>
				<div>
					<div class="row">
						<div class="12u skel-cell-mainContent">
							<!-- Content -->
								<article class="box is-post">
									<div class="box-head">
										<div class="post-infos">
											<ul class="tags">
												<li><a class="button" href="category/ji-suan-ji-wang-luo.html">计算机网络</a></li>
											</ul>
										</div>

										<div class="pennant pennant-alt date">2024-03-09</div>
										<h2>HTTP认识</h2>

										<span class="head-modify-time">修改于: 2024-04-06</span>

									</div>
									<p>HTTP, 超文本传输协议, 不提供数据包的传输功能. 属于 <strong>应用层协议</strong></p>
<p>本质为: 客户端和服务端约定好的一种通信格式 (就像秦始皇的车同轨书同文).</p>
<div class="section" id="osi">
<h2>OSI七层模型</h2>
<p>自底向上依次</p>
<ul class="simple">
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li>传输层: TCP就在这层, 规定需使用 <strong>字节流</strong> 传输.</li>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ul>
<div class="section" id="tcp">
<h3>TCP传输层</h3>
<p>TCP传输层规定需使用 <strong>字节流</strong> 传输.
但是很容易产生 TCP 粘包, 导致接收方无法理解哪些字节流属于同一个请求，这就是裸 TCP 连接的不可用性.
因此对于传输层的数据, 需要制定一个让对方通过 TCP 连接能看的懂的说明（类似于 OSI 表示层的作用）.</p>
<p><a class="reference internal" href="#rpc">RPC</a> （实际上 RPC 底层既可以是 TCP 也可以是 UDP） 和 HTTP 就是当前最流行的该说明的实现，
它们都将数据分为头部和数据两个部分，两部分天然用空行分隔防止粘包，
并在头部中指定数据部分大小，这样当接收方接收到数据后就能根据数据大小取出相应的字节流</p>
</div>
</div>
<div class="section" id="http-1">
<h2>HTTP状态码</h2>
<p>主要分类</p>
<dl class="docutils">
<dt>1xx</dt>
<dd>信息性</dd>
<dt>2xx</dt>
<dd>成功状态码</dd>
<dt>3xx</dt>
<dd><p class="first">重定向状态码;</p>
<p>重定向状态码用来告诉浏览器客户端，它们访问的资源已被移动， Web服务器发送一个重定向状态码和一个可选的Location Header, 告诉客户端新的资源地址在哪。</p>
<p>浏览器客户端会自动用Location中提供的地址，重新发送新的Request。 这个过程对用户来说是透明的。</p>
<p class="last">301和302 非常相似， 一个是永久转移，一个是临时转移。</p>
</dd>
</dl>
<p>（SEO中，搜索引擎如果碰到301， 比如网页A用301重定向到网页B，搜索引擎可以肯定网页A永久性改变地址，就会把网页B当做唯一有效目标）</p>
<dl class="docutils">
<dt>4xx</dt>
<dd><p class="first">客户端错误状态码;</p>
<p class="last">发生于客户端会发送一些服务器无法处理的东西，比如格式错误的Request, 或者最常见的是， 请求一个不存在的URL</p>
</dd>
<dt>5xx</dt>
<dd><p class="first">服务器错误状态码;</p>
<p class="last">对于客户端发送的有效Request, Web服务器自身出错</p>
</dd>
</dl>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="47%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">状态码</th>
<th class="head">状态消息</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>100</td>
<td>Continue(继续)</td>
<td>收到了请求的起始部分，客户端应该继续请求</td>
</tr>
<tr><td>101</td>
<td>Switching Protocols (切换协议)</td>
<td>服务器正根据客户端的指示将协议切换成UpdateHeader列出的协议</td>
</tr>
<tr><td>200</td>
<td>OK</td>
<td>服务器成功处理了请求（这个是我们见到最多的）</td>
</tr>
<tr><td>201</td>
<td>Created(已创建)</td>
<td>对于那些要服务器创建对象的请求来说，资源已创建完毕</td>
</tr>
<tr><td>202</td>
<td>Accepted(已接受)</td>
<td>请求已接受，但服务器尚未处理</td>
</tr>
<tr><td>203</td>
<td>Non-Authoritative Information（非权威信息）</td>
<td>服务器已将事务成功处理，
只是实体Header包含的信息不是来自原始服务器，
而是来自资源的副本。</td>
</tr>
<tr><td>204</td>
<td>NoContent（没有内容）</td>
<td>Response中包含一些Header和一个状态行，
但不包括实体的主题内容(没有responsebody)</td>
</tr>
<tr><td>205</td>
<td>ResetContent（重置内容）</td>
<td>另一个主要用于浏览器的代码。
意思是浏览器应该車置当前页面上所有的HTML表单</td>
</tr>
<tr><td>206</td>
<td>PartialContent（部分内容）</td>
<td>部分请求成功; 表示请求部分资源,
比如下载时断点续传</td>
</tr>
<tr><td>300</td>
<td>Multiple Choices (多项选择)</td>
<td>客户端请求了实际指向多个资源的URL。
这个代码是和一个选项列表一起返这回的，
然后用户就可以选择他希望的选项了</td>
</tr>
<tr><td>301</td>
<td>Moved Permanently（永久移除）</td>
<td>请求的URL已移走。
Response中应该包含一个LocationURL，说明资源现在所处的位置</td>
</tr>
<tr><td>302</td>
<td>Found（已找到）</td>
<td>与状态码301类似。但这里的移除是临时的。
客户端会使用Location中给出的URL，重新发送新的HTTP request</td>
</tr>
<tr><td>303</td>
<td>See Other</td>
<td>类似302</td>
</tr>
<tr><td>304</td>
<td>Not Modified NotModified（未修改）</td>
<td>客户的缓存资源是最新的，要客户端使用缓存</td>
</tr>
<tr><td>305</td>
<td>UseProxy（使用代理）</td>
<td>必须通过代理访问资源，代理的地址在Response的Location中</td>
</tr>
<tr><td>306</td>
<td>未使用</td>
<td>这个状态码当前没使用</td>
</tr>
<tr><td>307</td>
<td>Temporary Redirect(临时重定向)</td>
<td>类似302</td>
</tr>
<tr><td>400</td>
<td>Bad Request</td>
<td>告诉客户端，它发送了一个错误的请求。
发送的Request中的数据有错误(比如：表单有错误，Cookie有错误)</td>
</tr>
<tr><td>401</td>
<td>Unauthorized(未授权)</td>
<td>需要客户端对自己认证</td>
</tr>
<tr><td>402</td>
<td>PaymentRequired（要求付款）</td>
<td>这个状态还没被使用，保留给将来用</td>
</tr>
<tr><td>403</td>
<td>Forbidden</td>
<td>请求被服务嚣拒绝了</td>
</tr>
<tr><td>404</td>
<td>Not Found</td>
<td>未找到资源</td>
</tr>
<tr><td>405</td>
<td>Method Not Allowed</td>
<td>不支持该Request的方法。</td>
</tr>
<tr><td>406</td>
<td>Not Acceptable（无法接受）</td>
<td>&nbsp;</td>
</tr>
<tr><td>407</td>
<td>Proxy Authentication Required</td>
<td>与状态码401类似，用于需要进行认证的代理服务器</td>
</tr>
<tr><td>408</td>
<td>Request Timeout</td>
<td>如果客户端完成请求时花费的时间太长，
服务器可以回送这个状态码并关闭连接</td>
</tr>
<tr><td>409</td>
<td>Conflict</td>
<td>发出的请求在资源上造成了一些冲中突</td>
</tr>
<tr><td>410</td>
<td>Gone(消失了)</td>
<td>服务器曾经有这个资源，现在没有了，与状态码404类似</td>
</tr>
<tr><td>411</td>
<td>Length Required</td>
<td>服务器要求在Request中包含Content-Length。</td>
</tr>
<tr><td>412</td>
<td>Precondition Failed(先决条件失败)</td>
<td>&nbsp;</td>
</tr>
<tr><td>413</td>
<td>Request Entity Too Large</td>
<td>客户端发送的实体主体部分比服务器能够或者希望处理的要大</td>
</tr>
<tr><td>414</td>
<td>Request-URI Too Long</td>
<td>客户端发送的请求所携带的URL超过了服务器能够或者希望处理的长度</td>
</tr>
<tr><td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法理解或不支持客户端所发送的实体的内容类型</td>
</tr>
<tr><td>416</td>
<td>Requested Range Not Satisfiable
(所请求的范围未得到满足)</td>
<td>比如断点续传的时候, Range指定的范围不存在</td>
</tr>
<tr><td>417</td>
<td>Expectation Failed(无法满足期望)</td>
<td>&nbsp;</td>
</tr>
<tr><td>500</td>
<td>Internal Server Error</td>
<td>服务器遇到一个错误，使其无法为请求提供服务</td>
</tr>
<tr><td>501</td>
<td>Not Implemented</td>
<td>客户端发起的请求超出服务器的能力范围
（比如，使用了服务器不支持的请求方法）时，使用此状态码。</td>
</tr>
<tr><td>502</td>
<td>Bad Gateway</td>
<td>代理使用的服务器遇到了上游的无效响应</td>
</tr>
<tr><td>503</td>
<td>Service Unavailable</td>
<td>服务器目前无法为请求提供服务，但过一段时间就可以恢复服务</td>
</tr>
<tr><td>504</td>
<td>Gateway Timeout</td>
<td>与状态吗408类似，但是响应来自网关或代理，
此网关或代理在等待另一台服务器
的响应时出现了超时</td>
</tr>
<tr><td>505</td>
<td>HTTP Version Not Supported</td>
<td>服务器收到的请求使用了它不支持的HTTP协议版本。
有些服务器不支持HTTP早期的HTTP协议版本, 也不支持太高协议版本</td>
</tr>
</tbody>
</table>
<p>参考: <a class="reference external" href="https://blog.csdn.net/sheinenggaosuwo/article/details/86700323">HTTP协议状态码查询，详解（200、206、500、416、403、404）</a></p>
</div>
<div class="section" id="section-1">
<h2>浏览器访问总是返回304</h2>
<p>因为浏览器会缓存之前请求过的文件。</p>
<p>当再次请求同一文件时,浏览器会先向服务器确认文件是否有更新,
如果没有更新则返回304状态码,使用缓存文件。
这是浏览器的默认缓存行为,可以通过开发者工具清除缓存来避免。</p>
<p>当浏览器再次请求同一文件时,它会使用HTTP协议中的条件请求头来询问服务器该文件是否有更新。
主要有两种方式:</p>
<dl class="docutils">
<dt>ETag</dt>
<dd>ETag是服务器为每个资源生成的一个唯一标识符。
当浏览器第一次请求资源时,服务器会在响应头中包含这个ETag。
之后浏览器重新请求同一资源时,会将之前收到的ETag添加到请求头If-None-Match中发送给服务器。
服务器收到后会比对ETag, 如果资源没有更新, 则返回304状态码, 告知浏览器可以使用缓存的资源。</dd>
<dt>Last-Modified</dt>
<dd>服务器在响应头中包含一个Last-Modified字段,表示资源的最后修改时间。
浏览器后续请求时,会将前一次收到的Last-Modified时间作为请求头If-Modified-Since的值发送。
服务器收到后比对资源的实际修改时间,如果资源没有更新,则返回304状态码。</dd>
</dl>
<!-- 所以,浏览器通过在后续请求中添加If-None-Match或If-Modified-Since头,询问服务器资源是否有变化。 -->
<!-- 如果没有,服务器返回304状态码和少量头信息,浏览器就可以避免重新下载相同的资源,节省带宽。 -->
<!-- 你问的OPTIONS方法适用于跨域资源共享(CORS)预检请求,用于inquiring服务器支持的HTTP方法和其他CORS相关信息,与缓存控制无关。 -->
</div>
<div class="section" id="rpc-1">
<span id="rpc"></span><h2>杂谈-RPC</h2>
<p>RPC(Remote Procedure Call：远程方法调用，即可以像调用本地方法一样调用远端方法),
远程过程调用, 是一种通信协议, 是一种远程过程调用技术, 是一种分布式计算技术、 设计模式.</p>
<p>跨越了 OSI 7层模型的 <cite>传输层</cite> 到 <cite>应用层</cite>.
其调用协议通常包含： <strong>传输协议</strong> 和 <strong>序列化协议</strong>。</p>
<dl class="docutils">
<dt>传输协议</dt>
<dd>比如著名的 grpc，它底层使用的是 http2 协议；还有 dubbo 一类的自定义报文的 tcp 协议</dd>
<dt>序列化协议</dt>
<dd><p class="first">例如基于文本编码的 json 协议；也有二进制编码的 protobuf、hession 等协议；还有针对 java 高性能、高吞吐量的 kryo 和 ftc 等序列化协议</p>
<p class="last">大部人理解误区的问题应该是： <a class="reference internal" href="#tcp-rpc">为什么要使用自定义 tcp 协议的 rpc 做后端进程通信？</a> .</p>
</dd>
</dl>
<p>RPC 比 HTTP 早出现 20 年左右，那为什么有了 RPC 之后还需要创建 HTTP 协议呢？
最主要原因：</p>
<ul class="simple">
<li>首先 RPC 只是一种实现方式（不是协议）针对这个实现方式不同的使用者可以定制不同的基于 RPC 的协议，
因此有许多基于 RPC 的协议例如 thrift 和 gRPC；</li>
<li>由于其灵活性，在 HTTP 还未出现之前，许多组织和机构都针对性的制定了自己的 RCP 协议，
例如我们平常使用安全卫士调用远程方法进行病毒查杀的时候，就用的是基于 RPC 的协议，
这种方案当一个公司主要业务是向客户提供服务时（C/S 模式）是可行的，
但考虑例如浏览器这样的业务（B/S 模式）浏览器同时需要提供自身服务器的服务和调用其他组织服务器的服务，
那就可能会涉及多个 RPC 协议，这显然不能接受，于是一个统一的标准协议 HTTP 就诞生了；
实际上如今越来越多的软件都是 B/S 模式，既可以在手机，平板上使用，也可以在浏览器上使用，
RPC 逐渐被 HTTP 大范围取代，目前主要用于公司内部的微服务提供；
其次：随着 HTTP 版本的优化，HTTP 2 在数据传输方面（头部压缩等机制）相对于 RPC 的优势更加明显，这也是 HTTP 逐渐取代 RPC 的原因；</li>
</ul>
<div class="section" id="httprpc">
<h3>HTTP与RPC区别</h3>
<dl class="docutils">
<dt>连接池原生支持</dt>
<dd><p class="first">基于 TCP 的 RPC 协议底层默认是 TCP 长连接，但在此基础之上，RCP 协议还创建了连接池的概念，
就是建立一个用于存放 TCP 连接的池子，当下次需要使用的时候直接从池中取出对应连接进行复用即可，
这缓解了服务器压力，适合高并发的情况；</p>
<p class="last">HTTP 本身没有默认支持连接池，不过许多编程语言都增加了 HTTP 的连接池功能;</p>
</dd>
<dt>数据传输方面</dt>
<dd><p class="first">在传输数据时我们应该尽可能将其转换为二进制形式（序列化）方便计算机识别，避免无谓的资源消耗</p>
<ul class="last simple">
<li>字符串可以通过哈夫曼编码转换为二进制形式</li>
<li>数字天然就可以转换为二进制形式</li>
<li>结构体数据<ul>
<li>在 HTTP 2 出现头部压缩之前，HTTP 1.x 主要是通过 Json 实现</li>
<li>RPC 主要是通过 protobuf 实现数据的序列化 (protobuf 的实现更加轻量级，效率更高)</li>
</ul>
</li>
</ul>
</dd>
<dt>通信协议</dt>
<dd>HTTP 使用文本协议，RPC 使用二进制协议。</dd>
<dt>调用方式</dt>
<dd>HTTP 接口通过 URL 进行调用，RPC 接口通过函数调用进行调用。</dd>
<dt>参数传递方式</dt>
<dd>HTTP 接口使用 URL 参数或者请求体进行参数传递，RPC 接口使用函数参数进行传递。</dd>
<dt>接口描述方式</dt>
<dd>HTTP 接口使用 RESTful 架构描述接口，RPC 接口使用接口定义语言（IDL）描述接口。</dd>
<dt>性能表现不同</dt>
<dd>RPC 接口通常比 HTTP 接口更快，因为它使用二进制协议进行通信，而且使用了一些性能优化技术，例如连接池、批处理等。此外，RPC 接口通常支持异步调用，可以更好地处理高并发场景。</dd>
<dt>应用场景</dt>
<dd><p class="first">HTTP 接口适用于 Web 应用程序和浏览器之间的通信。
它通常用于传输 HTML、CSS、JavaScript 和其他 Web 资源，以及 RESTful 风格的 API 服务。</p>
<p class="last">RPC 接口适用于分布式系统之间的通信。
它可以在多种编程语言之间进行通信，支持多种协议和数据格式。
RPC 接口通常用于处理高并发、高吞吐量的场景，例如大型的分布式计算、大数据处理等。</p>
</dd>
</dl>
<p>HTTP 接口和 RPC 接口的相同之处在于，它们都是用于接口通信的协议。
它们都需要定义接口、参数和返回值等信息，并通过网络进行通信。
此外，它们都支持多种数据格式的编解码，可以根据需求进行灵活的选择。</p>
<p>属于两个维度, HTTP是通信协议, RPC是远程过程调用(调用远程服务器的本地方法, 相反的是自己调用自己本地方法).</p>
<p>RPC可以基于HTTP使用, 也可以基于其他协议(如TCP)使用, 一般都是基于TCP, 因为TCP协议在传输层, 比HTTP的应用层更底层, 传输更快.</p>
<p>RPC是面向过程的，最终的目的就是为了传输对象，所以只需要网络通信+对象的序列化和反序列化就行了
(rpc关注的应该是传输协议和序列化协议)</p>
<p>HTTP冗余度，复杂性，性能都不太行，而且还要指定ip端口，请求资源路径等等</p>
<p>至于为什么使用封装好的RPC,</p>
<p>一是因为RPC不局限于使用HTTP协议(HTTP协议较冗余)</p>
<p>二是都是内部使用(很少有给外部提供直接调用方法的), 不用考虑通用性(HTTP通用性较好)</p>
<div class="admonition tip">
<p class="first admonition-title">技巧</p>
<p class="last">一般RPC都是对内, HTTP对外使用</p>
</div>
</div>
<div class="section" id="tcp-rpc">
<h3>为什么要使用自定义 tcp 协议的 rpc 做后端进程通信？</h3>
<p>要解决这个问题就应该搞清楚 http 使用的 tcp 协议，和我们自定义的 tcp 协议在报文上的区别。</p>
<p>首先要 <strong>否认</strong> 一点 http 协议相较于 自定义tcp 报文协议，增加的开销在于连接的建立与断开。</p>
<ul class="simple">
<li>第一、http协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接</li>
<li>第二、http也可以使用 protobuf 这种二进制编码协议对内容进行编码</li>
</ul>
<p>因此二者即 http 和 rpc 最大的区别还是在 <strong>传输协议</strong> 上。</p>
<p>通用定义的http1.1协议的tcp报文包含太多废信息，一个POST协议的格式大致如下:</p>
<pre class="literal-block">
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

&lt;html&gt;
  &lt;body&gt;Hello World&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>即使编码协议也就是 body 是使用二进制编码协议，报文元数据也就是header头的键值对却使用了文本编码，非常占字节数。
如上图所使用的报文中有效字节数仅仅占约 30%，也就是70%的时间用于传输元数据废编码。
当然实际情况下报文内容可能会比这个长，但是报头所占的比例也是非常可观的。</p>
<p>那么假如我们使用自定义tcp协议的报文如下</p>
<div class="figure">
<img alt="自定义报文" src="doc-raw/resources/images/2024-04-07-13-41-45.png" style="width: 480px;" />
</div>
<p>报头占用的字节数也就只有16个byte，极大地精简了传输内容。
这也就是为什么后端进程间通常会采用 <cite>自定义tcp协议 的 rpc 来进行通信的原因</cite>。</p>
<dl class="docutils">
<dt>不单效率那么简单</dt>
<dd><p class="first">所谓的效率优势是针对 http1.1协议 来讲的，
http2.0协议 已经优化编码效率问题，
像 grpc 这种 rpc 库使用的就是 http2.0协议。</p>
<p>这么来说吧，http容器的性能测试单位通常是kqps，自定义tpc协议则通常是以 10kqps 到 100kqps 为基准</p>
<p class="last">简单来说成熟的 rpc库相对 http容器，更多的是封装了 “服务发现”，&quot;负载均衡&quot;，“熔断降级” 一类面向服务的高级特性。
可以这么理解，rpc框架是面向服务的更高级的封装。
如果把一个http servlet 容器上封装一层服务发现 和 函数代理调用，那它就已经可以做一个rpc框架了。</p>
</dd>
<dt>所以为什么要用rpc调用？</dt>
<dd><p class="first">因为良好的 rpc 调用是 面向服务的封装，针对服务的 可用性 和 效率 等都做了优化。单纯使用http调用则缺少了这些特性。</p>
<p class="last">可以这样说：用http不是因为它性能好，而是因为它普适，随便一个web容器就能跑起来你的应用。</p>
</dd>
</dl>
</div>
<div class="section" id="rpc-2">
<h3>RPC 底层实现</h3>
<p>一张图说明</p>
<div class="figure">
<img alt="rpc与http结构联系" src="doc-raw/resources/images/2024-04-07-13-45-47.png" style="width: 480px;" />
</div>
<p>上图是一个比较完整的关系图，这时我们发现HTTP（图中蓝色框）出现了两次。</p>
<ul class="simple">
<li>其中一个是 和 RPC并列的，都是跨应用调用方法的解决方案；</li>
<li>另一个则是被RPC包含的，是RPC通信过程的可选协议之一。</li>
</ul>
<p>通常， <strong>RPC要求在调用方中放置被调用的方法的接口</strong>。
调用方只要调用了这些接口，就相当于调用了被调用方的实际方法，十分易用。
于是，调用方可以像调用内部接口一样调用远程的方法，而不用封装参数名和参数值等操作。</p>
<div class="figure">
<img alt="rpc接口" src="doc-raw/resources/images/2024-04-07-13-49-36.png" style="width: 480px;" />
</div>
<dl class="docutils">
<dt>实现过程</dt>
<dd><ul class="first simple">
<li>首先，调用方调用的是接口，必须得为接口构造一个假的实现。显然，要使用动态代理。这样，调用方的调用就被动态代理接收到了。</li>
<li>第二、动态代理接收到调用后，应该想办法调用远程的实际实现。这包括下面几步：<ol class="arabic">
<li>识别具体要调用的远程方法的 IP、端口</li>
<li>将调用方法的入参进行序列化</li>
<li>通过通信将请求发送到远程的方法中</li>
</ol>
</li>
<li>第三、这样，远程的服务就接收到了调用方的请求。它应该：<ol class="arabic">
<li>反序列化各个调用参数</li>
<li>定位到实际要调用的方法，然后输入参数，执行方法</li>
<li>按照调用的路径返回调用的结果</li>
</ol>
</li>
</ul>
<div class="figure">
<img alt="rpc过程" src="doc-raw/resources/images/2024-04-07-13-51-21.png" style="width: 480px;" />
<p class="caption">过程图</p>
</div>
<p class="last">这样，RPC操作就完成了。
调用方 调用内部的一个方法，会被 RPC框架 偷梁换柱为 远程 的 一个方法。
他们之间的通信数据可读性不需要好，只需要RPC框架能读懂即可，因此效率可以更高。
通常使用UDP或者TCP作为通讯协议，当然也可以使用HTTP。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="websocket">
<h2>杂谈-WebSocket</h2>
<div class="section" id="http-websocket">
<h3>HTTP 与 WebSocket</h3>
<p><cite>WebSocket</cite> 协议实际上也是请求方与服务器之间用来进行数据传输的，
它比 HTTP 协议初始版本出现的时间更晚，那为什么有了 <cite>HTTP</cite> 协议之后还要创建一个 <cite>WebSocket</cite> 协议呢？</p>
<p>实际上早期的 <cite>HTTP 1.x</cite> 版本中，服务器一直是作为被动响应的那一方，
也就是说服务器只有接收到来自请求方的请求之后之后才能针对性的做出响应；
但有时候服务器可以判断请求方请求的资源是否必须与其他资源关联使用，
如果服务器能够主动推送该资源就能避免请求方发送额外的请求，从而优化性能，
因此 <cite>HTTP 2</cite> 开始就引入了服务器推送机制解决上面的问题（服务器不一定需要在响应请求方的时候才能推送，也可以主动推送）
但 <cite>HTTP 2</cite> 直到 <cite>2015</cite> 年才推出，
早期的 <cite>HTTP 1.x</cite> 版本设计用于在网页上展示文本等信息，
随着网页游戏的诞生设计者意识到了服务器需要主动和请求方进行数据传输，
在 <cite>HTTP 2</cite> 出现之前的这个阶段，诞生了 <cite>WebSocket</cite> 用于解决这个问题！</p>
</div>
<div class="section" id="section-2">
<h3>现代化传输方式</h3>
<p>我们都知道，日常生活中使用浏览器可以用来看文字信息，看视频和玩网页游戏等，
这就涉及到了应用 <cite>HTTP</cite> 和 <cite>WebSocket</cite> 两种协议的过程，
所以在 <cite>HTTP 2</cite> 诞生前，浏览器与服务器建立起 TCP 连接后，
通常先利用 <cite>HTTP</cite> 协议进行一次数据传输，当需要使用到 <cite>WebSocket</cite> 协议时，
请求方会在请求报文的头部字段添加 <cite>Upgrade</cite> 字段 (表示切换协议)，
对应值为 <cite>WebSocket</cite> 表示将 <cite>HTTP</cite> 协议升级到 <cite>WebSocket</cite> 协议（但这并不意味着 <cite>WebSocket</cite> 协议基于 <cite>HTTP</cite> 协议，这样做只是为了切换更加方便）
同时添加 <cite>Sec-WebSocket-Key</cite> 字段并将值设置为随机生成的 <cite>base64</cite> 码，
服务器收到请求后会检查是否支持 <cite>WebSocket</cite> 协议，
如果支持就会利用公开的算法将这段 <cite>base64</cite> 码加密后放在响应报文字段中返回，
并返回状态码 101 <cite>Switching Protocals`（协议切换）请求方接收到响应报文后会利用同样的算法将自身的 base64 码加密，
如果结果和响应报文中的一致则双方的 `WebSocket</cite> 连接便建立，用时 <cite>1 RTT</cite></p>
</div>
</div>
<div class="section" id="tcp-1">
<h2>杂谈-TCP 粘包</h2>
<dl class="docutils">
<dt>发送端粘包：</dt>
<dd><p class="first">TCP 连接中会将报文段限制在 MSS（Max Segment Size） 大小，
因此一些报文段时常需要进行分割，
而 TCP 内部默认开启 Nagle 算法对较小的报文进行合并发送，
这是导致粘包的一个原因，可以通过关闭 Nagle 算法避免；</p>
<p class="last">TCP 连接的发送方会将报文段放在缓存区，尽量等待缓存区装满之后再发送，这也会导致粘包；</p>
</dd>
<dt>接收端粘包：</dt>
<dd>TCP 连接的接收方未及时取走到达缓存区的报文段导致粘包</dd>
</dl>
<p>参考:</p>
<ul class="simple">
<li><a class="reference external" href="https://zhuanlan.zhihu.com/p/668188907">从 RPC 到 HTTP 到 WebSocket</a></li>
<li><a class="reference external" href="https://www.cnblogs.com/liang1101/p/13083965.html">RPC 和 HTTP 理解，看完这一篇就够了</a></li>
<li><a class="reference external" href="https://segmentfault.com/a/1190000043684100">HTTP 与 RPC 接口区别</a></li>
</ul>
</div>

								</article>
						</div>
					</div>
				</div>
			</section>
	</div>
</div>

				</div>
			</div>



		<!-- Sider Bar -->
		<div id="right-side-bar">
	<nav>
		<div id="top-toc-tree-container" class="fixed-container">
			<div class="toc-contents-title">
				<h4 id="toc-contents-title-text">Contents</h4>
				<!-- <span class="tool-tip-text">点击隐藏</span> -->
			</div>
			<div id="toc-tree-container">
 <ul class="toc-tree visible">
  <li class="toc-h0">
   <a class="" href="#osi">
    OSI七层模型
   </a>
   <ul class="toc-tree visible">
    <li class="toc-h1">
     <a class="" href="#tcp">
      TCP传输层
     </a>
    </li>
   </ul>
  </li>
  <li class="toc-h0">
   <a class="" href="#http-1">
    HTTP状态码
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-1">
    浏览器访问总是返回304
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#rpc-1">
    杂谈-RPC
   </a>
   <ul class="toc-tree visible">
    <li class="toc-h1">
     <a class="" href="#httprpc">
      HTTP与RPC区别
     </a>
    </li>
    <li class="toc-h1">
     <a class="" href="#tcp-rpc">
      为什么要使用自定义 tcp 协议的 rpc 做后端进程通信？
     </a>
    </li>
    <li class="toc-h1">
     <a class="" href="#rpc-2">
      RPC 底层实现
     </a>
    </li>
   </ul>
  </li>
  <li class="toc-h0">
   <a class="" href="#websocket">
    杂谈-WebSocket
   </a>
   <ul class="toc-tree visible">
    <li class="toc-h1">
     <a class="" href="#http-websocket">
      HTTP 与 WebSocket
     </a>
    </li>
    <li class="toc-h1">
     <a class="" href="#section-2">
      现代化传输方式
     </a>
    </li>
   </ul>
  </li>
  <li class="toc-h0">
   <a class="" href="#tcp-1">
    杂谈-TCP 粘包
   </a>
  </li>
 </ul>
</div>

		</div>
	</nav>
	<div id="sidebar-tools" class="fixed-container no-active cant-select">
		<!-- 按钮 使用 content 绘制图标 -->
	</div>
	<div id="sidebar-tool-back-top" class="fixed-container cant-select">
		<!-- 按钮 使用 content 绘制图标 -->
	</div>
		</div>

		<!-- Footer Wrapper -->
			<div id="footer-wrapper">
				<!-- Footer -->
					<section id="footer" class="container">
						<div class="row">
							<div class="8u">
								<section>
									<header>
										<h2>Latest articles</h2>
									</header>
									<ul class="dates">
										<li>
											<span class="date">Dec <strong>25</strong></span>
											<h3><a href="yq-docs-rear-end-python-Web-framework-Django-Tutorial-index.html">Django教程</a></h3>
											<p><p class="first last">Django教程</p>
</p>
										</li>
										<li>
											<span class="date">Dec <strong>25</strong></span>
											<h3><a href="yq-docs-rear-end-python-Web-framework-Django-Tutorial-model-enum.html">模型选择枚举类型</a></h3>
											<p><p class="first last">模型选择枚举类型</p>
</p>
										</li>
										<li>
											<span class="date">Dec <strong>25</strong></span>
											<h3><a href="yq-docs-rear-end-python-Web-framework-Django-Tutorial-query-related_name-and-related_query_name.html">反向查询related_name和related_query_name</a></h3>
											<p><p class="first last">反向查询related_name和related_query_name</p>
</p>
										</li>
										<li>
											<span class="date">Dec <strong>24</strong></span>
											<h3><a href="yq-docs-operating-system-Mac-turorial-pf.html">防火墙控制pf（Packet Filter）</a></h3>
											<p><p class="first last">防火墙控制pf（Packet Filter）</p>
</p>
										</li>
									</ul>
								</section>
							</div>
						</div>
						<div class="row">
							<div class="4u">
								<section>
									<header>
										<h2>Blogroll</h2>
									</header>
									<ul class="divided">
											<li><a href="https://yq-yqr.readthedocs.io/zh/blog-theme/blog.html">旧版(迁移中)</a></li>
											<li><a href="https://getpelican.com/">Pelican</a></li>
											<li><a href="https://www.python.org/">Python.org</a></li>
											<li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
									</ul>
								</section>
							</div>
							<div class="4u">
								<section>
									<header>
										<h2>Categories</h2>
									</header>
									<ul class="divided">
											<li><a href="/category/ai.html">AI</a></li>
											<li><a href="/category/an-quan.html">安全</a></li>
											<li><a href="/category/ban-ben-kong-zhi.html">版本控制</a></li>
											<li><a href="/category/cao-zuo-xi-tong.html">操作系统</a></li>
									</ul>
								</section>
							</div>

							<div class="4u">
								<section>
									<header>
										<h2>SITEMAP</h2>
									</header>

									<ul class="divided">
												<li><a href="/authors.html">作者</a></li>
												<li><a href="/categories.html">分类</a></li>
												<li><a href="/archives.html">归档</a></li>
												<li><a href="/tags.html">标签</a></li>
									</ul>
								</section>
							</div>

							<div class="4u">

								<section>
									<header>
										<h2>Contact</h2>
									</header>
									<ul class="social">
									</ul>
								</section>
							</div>
						</div>
						<div class="row">
							<div class="12u">
								<!-- Copyright -->
									<div id="copyright">
										<ul class="links">
											<li>&copy; YanQue 2019-2024	</li>
											<!-- <li>Images: <a href="http://facebook.com/DreametryDoodle">Dreametry Doodle</a> + <a href="http://iconify.it">Iconify.it</a></li>
											<li>Design: <a href="http://html5up.net">HTML5 UP</a></li> -->
										</ul>
									</div>
							</div>
						</div>
					</section>
			</div>

		</div>

		<!-- 其他 -->

			<div style="position: fixed;">
				<!-- 深色模式粒子效果 -->
				<!-- <canvas id="universe" width="1428" height="993" data-relingo-block="true" data-relingo-parsed="true"></canvas> -->
				<!-- 深色模式下添加粒子效果canvas -->
				<canvas id="universe" width="1312" height="880"></canvas>
			</div>

		<script src="/theme/js/jquery-3.7.1.min.js"></script>
		<script src="/theme/js/jquery.dropotron.js"></script>
		<script src="/theme/js/config.js"></script>
		<script src="/theme/skel-s0.4.8/skel.min.js"></script>
		<script src="/theme/skel-s0.4.8/skel-panels.min.js"></script>
		<!-- <script src="/theme/js/skel.min.js"></script>
		<script src="/theme/js/skel-panels.min.js"></script> -->
		<script src="/theme/js/backloading.js"></script>
		<script src="/theme/js/canvas/dark.js"></script>
<script type="text/javascript">
	function addEvent() {
		$("#toc-contents-title-text").click(function() {
			$("#top-toc-tree-container").toggleClass("no-active");
			$("#sidebar-tools").toggleClass("no-active");
		})
		$("#sidebar-tools").click(function() {
			$("#top-toc-tree-container").toggleClass("no-active");
			$("#sidebar-tools").toggleClass("no-active");
		})
		$("#sidebar-tool-back-top").click(function() {
			// window.scrollTo(0, 0);
			window.scrollTo({
				top: 0,
				left: 0,
				behavior: 'smooth'
			});
		})
	}
	addEvent()
</script>
		<!--[if lte IE 8]><script src="js/html5shiv.js"></script><link rel="stylesheet" href="/theme/css/ie8.css" /><![endif]-->
	</body>
</html>