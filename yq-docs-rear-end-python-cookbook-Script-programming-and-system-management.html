
<!DOCTYPE HTML>
<!--
	Dopetrope 2.0 by HTML5 UP
	html5up.net | @n33co
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html data-theme="dark">
	<head>
			<title>书言</title>
			<meta http-equiv="content-type" content="text/html; charset=utf-8" />
			<meta charset="utf-8" />

			<!-- <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,900,300italic" rel="stylesheet" /> -->
			<link rel="stylesheet" href="/theme/css/custom-pygment.css" />
			<noscript>
				<link rel="stylesheet" href="/theme/css/skel-noscript.css" />
				<link rel="stylesheet" href="/theme/css/style.css" />
				<link rel="stylesheet" href="/theme/css/style-desktop.css" />
			</noscript>

		<!-- tipuesearch 放在这, 因为搜索框是全局定义的 -->
		<link rel="stylesheet" href="/theme//Tipue-Search-5.0.0/tipuesearch.css" />
		<link rel="stylesheet" href="/theme//Tipue-Search-5.0.0/custom/tipuesearch-custom.css" />
		<link rel="stylesheet" href="/theme/css/alabaster.css" />
		<link rel="stylesheet" href="/theme/css/custom-alabaster.css" />
		<!-- <link rel="stylesheet" href="/theme/fontawesome-free-6.5.1-web/css/all.min.css" /> -->
		<!--  <link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-brands-400.woff2" />
		<link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-regular-400.woff2" />
		<link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-solid-900.woff2" />
		<link rel="preload" as="font" type="font/woff2" crossorigin href="/theme/fontawesome-free-6.5.1-web/webfonts/fa-v4compatibility.woff2" /> -->


	</head>
	<body class="no-sidebar">

		<!-- 内容 -->
		<div>

			<!-- Header Wrapper -->
			<div id="header-wrapper">
				<div class="container">
					<div class="row">
						<div class="12u">

							<!-- Header -->
								<section id="header">

									<!-- Logo -->
									<div class="page-home">
										<h1><a href="/">HOME</a></h1>
									</div>

									<!-- Nav -->
									<div class="page-menu">
										<nav id="nav">
											<ul>

												<!-- categories -->
														<li ><a href="/category/ai.html">AI</a></li>
														<li ><a href="/category/an-quan.html">安全</a></li>
														<li ><a href="/category/ban-ben-kong-zhi.html">版本控制</a></li>
														<li ><a href="/category/cao-zuo-xi-tong.html">操作系统</a></li>
														<li ><a href="/category/chang-yong-gong-ju-shi-yong.html">常用工具使用</a></li>
														<li ><a href="/category/da-shu-ju.html">大数据</a></li>
														<li><a href="/categories.html">More...</a></li>
											</ul>
										</nav>
									</div>
								</section>

						</div>
					</div>
					<div class="row page-head-search">
						<form class="navbar-search" action="/search.html" role="search">
							<!-- <button class="fa-solid fa-magnifying-glass" type="submit"></button> -->
							<button type="submit"></button>
							<input type="text" name="q" id="tipue_search_input" autocomplete="off" placeholder="Search...">
							<!-- <i class="fa-solid fa-magnifying-glass"></i> -->
						</form>
					</div>
  <div class="row page-head page-article persistent">
    <div class="page-head-title">
      <h2>脚本编程与系统管理</h2>
    </div>
    <div class="page-head-content">
      By
	  <a href="author/yanque.html">YanQue</a>
      , 20 二月 2023
      , Category:
	  <a href="category/hou-duan-python.html">后端; python</a>
    </div>
	<div class="red-line">
    </div>
  </div>
				</div>

				<!-- 头部下方动效 -->
				<div class="waves-area">
					<section class="main-hero-waves-area waves-area">
						<svg class="waves-svg" preserveAspectRatio="none" shape-rendering="auto" viewBox="0 24 150 28"
							 xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg">
							<defs>
								<path
										d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"
										id="gentle-wave"></path>
							</defs>
							<g class="parallax">
								<use href="#gentle-wave" x="48" y="0"></use>
								<use href="#gentle-wave" x="48" y="3"></use>
								<use href="#gentle-wave" x="48" y="5"></use>
								<use href="#gentle-wave" x="48" y="7"></use>
							</g>
						</svg>
					</section>
				</div>

			</div>

		<!-- Main Wrapper -->
			<div id="main-wrapper">
				<div class="container">
<div class="row">
	<div class="12u">
			<section>
				<div>
					<div class="row">
						<div class="12u skel-cell-mainContent">
							<!-- Content -->
								<article class="box is-post">
									<div class="box-head">
										<div class="post-infos">
											<ul class="tags">
												<li><a class="button" href="category/hou-duan-python.html">后端; python</a></li>
													<li><a class="button button-alt" href="tag/python.html">Python</a></li>

													<li><a class="button button-alt" href="tag/cookbook.html">Cookbook</a></li>

											</ul>
										</div>

										<div class="pennant pennant-alt date">2023-02-20</div>
										<h2>脚本编程与系统管理</h2>

										<span class="head-modify-time">修改于: 2023-02-20</span>

									</div>
									<p>许多人使用 Python 作为一个 shell 脚本的替代，用来实现常用系统任务的自动化，
如文件的操作，系统的配置等。本章的主要目标是描述关于编写脚本时候经常遇到的一
些功能。例如，解析命令行选项、获取有用的系统配置数据等等。第 5 章也包含了与文
件和目录相关的一般信息。</p>
<div class="section" id="section-2">
<h2>通过重定向/管道/文件接受输入</h2>
<dl class="docutils">
<dt>问题</dt>
<dd>你希望你的脚本接受任何用户认为最简单的输入方式。包括将命令行的输出通过
管道传递给该脚本、重定向文件到该脚本，或在命令行中传递一个文件名或文件名列表
给该脚本。</dd>
<dt>解决方案</dt>
<dd><p class="first">Python 内置的 fileinput 模块让这个变得简单。如果你有一个下面这样的脚本:</p>
<pre class="literal-block">
#!/usr/bin/env python3
import fileinput

with fileinput.input() as f_input:
  for line in f_input:
    print(line, end='')
</pre>
<p>作用就是将文件名传递给Python脚本让其输出文件内容</p>
<p>那么你就能以前面提到的所有方式来为此脚本提供输入。假设你将此脚本保存为
filein.py 并将其变为可执行文件，那么你可以像下面这样调用它，得到期望的输出:</p>
<pre class="last literal-block">
$ ls | ./filein.py # Prints a directory listing to stdout.
$ ./filein.py /etc/passwd # Reads /etc/passwd to stdout.
$ ./filein.py &lt; /etc/passwd # Reads /etc/passwd to stdout.
</pre>
</dd>
<dt>讨论</dt>
<dd><p class="first">fileinput.input() 创建并返回一个 FileInput 类的实例。该实例除了拥有一些
有用的帮助方法外，它还可被当做一个上下文管理器使用。因此，整合起来，如果我们
要写一个打印多个文件输出的脚本，那么我们需要在输出中包含文件名和行号，如下所
示:</p>
<pre class="literal-block">
&gt;&gt;&gt; import fileinput
&gt;&gt;&gt; with fileinput.input('/etc/passwd') as f:
&gt;&gt;&gt;   for line in f:
...     print(f.filename(), f.lineno(), line, end='')
...
/etc/passwd 1 ##
/etc/passwd 2 # User Database
/etc/passwd 3 #
&lt;other output omitted&gt;
</pre>
<p class="last">通过将它作为一个上下文管理器使用，可以确保它不再使用时文件能自动关闭，而
且我们在之后还演示了 FileInput 的一些有用的帮助方法来获取输出中的一些其他信
息。</p>
</dd>
</dl>
</div>
<div class="section" id="section-3">
<h2>终止程序并给出错误信息</h2>
<dl class="docutils">
<dt>问题</dt>
<dd>你想向标准错误打印一条消息并返回某个非零状态码来终止程序运行</dd>
<dt>解决方案</dt>
<dd><p class="first">你有一个程序像下面这样终止，抛出一个 SystemExit 异常，使用错误消息作为参
数。例如:</p>
<pre class="literal-block">
raise SystemExit('It failed!')
</pre>
<p class="last">它会将消息在 sys.stderr 中打印，然后程序以状态码 1 退出。</p>
</dd>
</dl>
</div>
<div class="section" id="section-4">
<h2>解析命令行选项</h2>
<dl class="docutils">
<dt>问题</dt>
<dd>你的程序如何能够解析命令行选项（位于 sys.argv 中）</dd>
<dt>解决方案</dt>
<dd><p class="first">argparse 模块可被用来解析命令行选项:</p>
<pre class="last literal-block">
import argparse

parser = argparse.ArgumentParser(description='Search some files')

parser.add_argument(dest='filenames',metavar='filename', nargs='*')

parser.add_argument('-p', '--pat',metavar='pattern', required=True,
                    dest='patterns', action='append',
                    help='text pattern to search for')
</pre>
</dd>
<dt>讨论</dt>
<dd><p class="first">argparse 模块是标准库中最大的模块之一，拥有大量的配置选项。</p>
<p>为 了 解 析 命 令 行 选 项， 你 首 先 要 创 建 一 个 ArgumentParser 实 例，并 使 用
add_argument() 方法声明你想要支持的选项。在每个 add_argument() 调用中，dest
参数指定解析结果被指派给属性的名字。metavar 参数被用来生成帮助信息。action
参数指定跟属性对应的处理逻辑，通常的值为 store , 被用来存储某个值或讲多个参数
值收集到一个列表中。下面的参数收集所有剩余的命令行参数到一个列表中。在本例中
它被用来构造一个文件名列表:</p>
<pre class="last literal-block">
parser.add_argument(dest='filenames',metavar='filename', nargs='*')
</pre>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">Python3 有一个click模块可以通过装饰器来使用, 更方便.</p>
</div>
</div>
<div class="section" id="section-5">
<h2>运行时弹出密码输入提示</h2>
<dl class="docutils">
<dt>问题</dt>
<dd>你写了个脚本，运行时需要一个密码。此脚本是交互式的，因此不能将密码在脚本
中硬编码，而是需要弹出一个密码输入提示，让用户自己输入</dd>
<dt>解决方案</dt>
<dd><p class="first">这时候 Python 的 getpass 模块正是你所需要的。你可以让你很轻松的弹出密码
输入提示，并且不会在用户终端回显密码。下面是具体代码:</p>
<pre class="literal-block">
import getpass
user = getpass.getuser()
passwd = getpass.getpass()

if svc_login(user, passwd): # You must write svc_login()
  print('Yay!')
else:
  print('Boo!')
</pre>
<p class="last">在此代码中，svc_login() 是你要实现的处理密码的函数，具体的处理过程你自己
决定。</p>
</dd>
<dt>讨论</dt>
<dd><p class="first">注意在前面代码中 getpass.getuser() 不会弹出用户名的输入提示。它会根据该
用户的 shell 环境或者会依据本地系统的密码库（支持 pwd 模块的平台）来使用当前用
户的登录名，
如果你想显示的弹出用户名输入提示，使用内置的 input 函数:</p>
<pre class="literal-block">
user = input('Enter your username: ')
</pre>
<p class="last">还有一点很重要，有些系统可能不支持 getpass() 方法隐藏输入密码。这种情况
下，Python 会提前警告你这些问题（例如它会警告你说密码会以明文形式显示）</p>
</dd>
</dl>
</div>
<div class="section" id="section-6">
<h2>获取终端的大小</h2>
<dl class="docutils">
<dt>问题</dt>
<dd>你需要知道当前终端的大小以便正确的格式化输出。</dd>
<dt>解决方案</dt>
<dd><p class="first">使用 os.get_terminal_size() 函数来做到这一点:</p>
<pre class="last literal-block">
&gt;&gt;&gt; import os
&gt;&gt;&gt; sz = os.get_terminal_size()
&gt;&gt;&gt; sz
os.terminal_size(columns=80, lines=24)
&gt;&gt;&gt; sz.columns
80
&gt;&gt;&gt; sz.lines
24
&gt;&gt;&gt;
</pre>
</dd>
<dt>讨论</dt>
<dd>有太多方式来得知终端大小了，从读取环境变量到执行底层的 ioctl() 函数等等。
不过，为什么要去研究这些复杂的办法而不是仅仅调用一个简单的函数呢？</dd>
</dl>
</div>
<div class="section" id="section-7">
<h2>执行外部命令并获取它的输出</h2>
<dl class="docutils">
<dt>问题</dt>
<dd>你想执行一个外部命令并以 Python 字符串的形式获取执行结果。</dd>
<dt>解决方案</dt>
<dd><p class="first">使用 subprocess.check_output() 函数。例如:</p>
<pre class="literal-block">
import subprocess
out_bytes = subprocess.check_output(['netstat','-a'])
</pre>
<p>这段代码执行一个指定的命令并将执行结果以一个字节字符串的形式返回。如果
你需要文本形式返回，加一个解码步骤即可。例如:</p>
<pre class="literal-block">
out_text = out_bytes.decode('utf-8')
</pre>
<p>如果被执行的命令以非零码返回，就会抛出异常。下面的例子捕获到错误并获取返
回码:</p>
<pre class="literal-block">
try:
  out_bytes = subprocess.check_output(['cmd','arg1','arg2'])
except subprocess.CalledProcessError as e:
  out_bytes = e.output # Output generated before error
  code = e.returncode # Return code
</pre>
<p>默认情况下，check_output() 仅仅返回输入到标准输出的值。如果你需要同时收
集标准输出和错误输出，使用 stderr 参数:</p>
<pre class="literal-block">
out_bytes = subprocess.check_output(['cmd','arg1','arg2'],
                                    stderr=subprocess.STDOUT)
</pre>
<p>如果你需要用一个超时机制来执行命令，使用 timeout 参数:</p>
<pre class="literal-block">
try:
  out_bytes = subprocess.check_output(['cmd','arg1','arg2'], timeout=5)
except subprocess.TimeoutExpired as e:
  ...
</pre>
<p>通常来讲，命令的执行不需要使用到底层 shell 环境（比如 sh、bash）。一个字符串
列表会被传递给一个低级系统命令，比如 os.execve() 。如果你想让命令被一个 shell
执行，传递一个字符串参数，并设置参数 shell=True . 有时候你想要 Python 去执行
一个复杂的 shell 命令的时候这个就很有用了，比如管道流、I/O 重定向和其他特性。
例如:</p>
<pre class="literal-block">
out_bytes = subprocess.check_output('grep python | wc &gt; out', shell=True)
</pre>
<p class="last">需要注意的是在 shell 中执行命令会存在一定的安全风险，特别是当参数来自于用
户输入时。这时候可以使用 shlex.quote() 函数来将参数正确的用双引用引起来。</p>
</dd>
<dt>讨论</dt>
<dd><p class="first">使用 check_output() 函数是执行外部命令并获取其返回值的最简单方式。但是，
如果你需要对子进程做更复杂的交互，比如给它发送输入，你得采用另外一种方法。这
时候可直接使用 subprocess.Popen 类:</p>
<pre class="literal-block">
import subprocess
# Some text to send
text = b'''
hello world
this is a test
goodbye
'''

# Launch a command with pipes
p = subprocess.Popen(['wc'],
                    stdout = subprocess.PIPE,
                    stdin = subprocess.PIPE)

# Send the data and get the output
stdout, stderr = p.communicate(text)
# To interpret as text, decode
out = stdout.decode('utf-8')
err = stderr.decode('utf-8')
</pre>
<p class="last">subprocess 模块对于依赖 TTY 的外部命令不合适用。例如，你不能使用它来自
动化一个用户输入密码的任务（比如一个 ssh 会话）。这时候，你需要使用到第三方模
块了，比如基于著名的 expect 家族的工具（pexpect 或类似的）</p>
</dd>
</dl>
</div>
<div class="section" id="section-8">
<h2>复制或者移动文件和目录</h2>
<dl class="docutils">
<dt>问题</dt>
<dd>你想要复制或移动文件和目录，但是又不想调用 shell 命令。</dd>
<dt>解决方案</dt>
<dd><p class="first">shutil 模块有很多便捷的函数可以复制文件和目录。使用起来非常简单:</p>
<pre class="literal-block">
import shutil

# Copy src to dst. (cp src dst)
shutil.copy(src, dst)

# Copy files, but preserve metadata (cp -p src dst)
shutil.copy2(src, dst)

# Copy directory tree (cp -R src dst)
shutil.copytree(src, dst)

# Move src to dst (mv src dst)
shutil.move(src, dst)
</pre>
<p>这些函数的参数都是字符串形式的文件或目录名。底层语义模拟了类似的 Unix 命
令，如上面的注释部分。
默认情况下，对于符号链接而已这些命令处理的是它指向的东西。例如，如果源文
件是一个符号链接，那么目标文件将会是符号链接指向的文件。如果你只想复制符号链
接本身，那么需要指定关键字参数 follow_symlinks , 如下：
如果你想保留被复制目录中的符号链接，像这样做:</p>
<pre class="literal-block">
shutil.copytree(src, dst, symlinks=True)
</pre>
<p>copytree() 可以让你在复制过程中选择性的忽略某些文件或目录。你可以提供一
个忽略函数，接受一个目录名和文件名列表作为输入，返回一个忽略的名称列表。例如:</p>
<pre class="literal-block">
def ignore_pyc_files(dirname, filenames):
  return [name in filenames if name.endswith('.pyc')]

shutil.copytree(src, dst, ignore=ignore_pyc_files)
</pre>
<p>由于忽略某种模式的文件名是很常见的，因此一个便捷的函数 ignore_patterns()
已经包含在里面了。例如:</p>
<pre class="last literal-block">
shutil.copytree(src, dst, ignore=shutil.ignore_patterns('*~', '*.pyc'))
</pre>
</dd>
<dt>讨论</dt>
<dd><p class="first">对于文件元数据信息，copy2()
这样的函数只能尽自己最大能力来保留它。访问时间、创建时间和权限这些基本信息
会被保留，但是对于所有者、ACLs、资源 fork 和其他更深层次的文件元信息就说不准
了，这个还得依赖于底层操作系统类型和用户所拥有的访问权限。你通常不会去使用
shutil.copytree() 函数来执行系统备份。</p>
<p>使用 copytree() 复制文件夹的一个棘手的问题是对于错误的处理。例如，在复制
过程中，函数可能会碰到损坏的符号链接，因为权限无法访问文件的问题等等。为了解
决这个问题，所有碰到的问题会被收集到一个列表中并打包为一个单独的异常，到了最
后再抛出。下面是一个例子:</p>
<pre class="literal-block">
try:
  shutil.copytree(src, dst)
except shutil.Error as e:
  for src, dst, msg in e.args[0]:
    # src is source name
    # dst is destination name
    # msg is error message from exception
    print(dst, src, msg)
</pre>
<p class="last">如果你提供关键字参数 ignore_dangling_symlinks=True ，这时候 copytree()
会忽略掉无效符号链接。
本节演示的这些函数都是最常见的。不过，shutil 还有更多的和复制数据相关的
操作。它的文档很值得一看，参考: <a class="reference external" href="https://docs.python.org/3/library/shutil.html">https://docs.python.org/3/library/shutil.html</a></p>
</dd>
</dl>
</div>
<div class="section" id="section-9">
<h2>创建和解压归档文件</h2>
<dl class="docutils">
<dt>问题</dt>
<dd>你需要创建或解压常见格式的归档文件（比如.tar, .tgz 或.zip）</dd>
<dt>解决方案</dt>
<dd><p class="first">shutil 模块拥有两个函数——make_archive() 和 unpack_archive() 可派上用
场:</p>
<pre class="literal-block">
&gt;&gt;&gt; import shutil
&gt;&gt;&gt; shutil.unpack_archive('Python-3.3.0.tgz')
&gt;&gt;&gt; shutil.make_archive('py33','zip','Python-3.3.0')
'/Users/beazley/Downloads/py33.zip'
&gt;&gt;&gt;
</pre>
<p>make_archive() 的 第 二 个 参 数 是 期 望 的 输 出 格 式。可 以 使 用
get_archive_formats() 获取所有支持的归档格式列表。例如:</p>
<pre class="last literal-block">
&gt;&gt;&gt; shutil.get_archive_formats()
[('bztar', &quot;bzip2'ed tar-file&quot;), ('gztar', &quot;gzip'ed tar-file&quot;),
('tar', 'uncompressed tar file'), ('zip', 'ZIP file')]
&gt;&gt;&gt;
</pre>
</dd>
<dt>讨论</dt>
<dd>Python 还有其他的模块可用来处理多种归档格式（比如 tarfile, zipfile, gzip, bz2）
的底层细节。不过，如果你仅仅只是要创建或提取某个归档，就没有必要使用底层库
了。可以直接使用 shutil 中的这些高层函数。
这些函数还有很多其他选项，用于日志打印、预检、文件权限等等。</dd>
</dl>
</div>
<div class="section" id="section-10">
<h2>通过文件名查找文件</h2>
<dl class="docutils">
<dt>问题</dt>
<dd>你需要写一个涉及到文件查找操作的脚本，比如对日志归档文件的重命名工具，你
不想在 Python 脚本中调用 shell，或者你要实现一些 shell 不能做的功能。</dd>
<dt>解决方案</dt>
<dd><p class="first">查找文件，可使用 os.walk() 函数，传一个顶级目录名给它。下面是一个例子，查
找特定的文件名并答应所有符合条件的文件全路径：</p>
<blockquote>
<p>#!/usr/bin/env python3.3
import os</p>
<dl class="docutils">
<dt>def findfile(start, name):</dt>
<dd><dl class="first last docutils">
<dt>for relpath, dirs, files in os.walk(start):</dt>
<dd><dl class="first last docutils">
<dt>if name in files:</dt>
<dd>full_path = os.path.join(start, relpath, name)
print(os.path.normpath(os.path.abspath(full_path)))</dd>
</dl>
</dd>
</dl>
</dd>
<dt>if __name__ == '__main__':</dt>
<dd>findfile(sys.argv[1], sys.argv[2])</dd>
</dl>
</blockquote>
<p class="last">findfile参数为初始查找目录与查找文件名</p>
</dd>
<dt>讨论</dt>
<dd>os.walk() 方法为我们遍历目录树，每次进入一个目录，它会返回一个三元组，包
含相对于查找目录的相对路径，一个该目录下的目录名列表，以及那个目录下面的文件
名列表。
对于每个元组，只需检测一下目标文件名是否在文件列表中。如果是就使用 os.
path.join() 合并路径。为了避免奇怪的路径名比如 ././foo//bar ，使用了另外两个
函数来修正结果。第一个是 os.path.abspath() , 它接受一个路径，可能是相对路径，
最后返回绝对路径。第二个是 os.path.normpath() ，用来返回正常路径，可以解决双
斜杆、对目录的多重引用的问题等。
尽管这个脚本相对于 UNIX 平台上面的很多查找来讲要简单很多，它还有跨平台
的优势。并且，还能很轻松的加入其他的功能。</dd>
</dl>
</div>
<div class="section" id="section-11">
<h2>读取配置文件</h2>
<dl class="docutils">
<dt>问题</dt>
<dd>怎样读取普通.ini 格式的配置文件？</dd>
<dt>解决方案</dt>
<dd><p class="first">configparser 模块能被用来读取配置文件。例如，假设你有如下的配置文件:</p>
<pre class="literal-block">
; config.ini
; Sample configuration file
[installation]
library=%(prefix)s/lib
include=%(prefix)s/include
bin=%(prefix)s/bin
prefix=/usr/local
# Setting related to debug configuration
[debug]
log_errors=true
show_warnings=False
[server]
port: 8080
nworkers: 32
pid-file=/tmp/spam.pid
root=/www/root
signature:
=================================
Brought to you by the Python Cookbook
=================================
</pre>
<p>下面是一个读取和提取其中值的例子:</p>
<pre class="literal-block">
&gt;&gt;&gt; from configparser import ConfigParser
&gt;&gt;&gt; cfg = ConfigParser()
&gt;&gt;&gt; cfg.read('config.ini')
['config.ini']
&gt;&gt;&gt; cfg.sections()
['installation', 'debug', 'server']
&gt;&gt;&gt; cfg.get('installation','library')
'/usr/local/lib'
&gt;&gt;&gt; cfg.getboolean('debug','log_errors')
True
&gt;&gt;&gt; cfg.getint('server','port')
8080
&gt;&gt;&gt; cfg.getint('server','nworkers')
32
&gt;&gt;&gt; print(cfg.get('server','signature'))
\=================================
Brought to you by the Python Cookbook
\=================================
&gt;&gt;&gt;
</pre>
<p>如果有需要，你还能修改配置并使用 cfg.write() 方法将其写回到文件中。例如:</p>
<pre class="last literal-block">
&gt;&gt;&gt; cfg.set('server','port','9000')
&gt;&gt;&gt; cfg.set('debug','log_errors','False')
&gt;&gt;&gt; import sys
&gt;&gt;&gt; cfg.write(sys.stdout)
</pre>
</dd>
<dt>讨论</dt>
<dd><p class="first">配置文件作为一种可读性很好的格式，非常适用于存储程序中的配置数据。在每个
配置文件中，配置数据会被分组（比如例子中的“installation”、“debug”和“server”）。
每个分组在其中指定对应的各个变量值。</p>
<p>对于可实现同样功能的配置文件和 Python 源文件是有很大的不同的。首先，配置
文件的语法要更自由些，下面的赋值语句是等效的:</p>
<pre class="literal-block">
prefix=/usr/local
prefix: /usr/local
</pre>
<p>配置文件中的名字是不区分大小写的。例如:</p>
<pre class="literal-block">
&gt;&gt;&gt; cfg.get('installation','PREFIX')
'/usr/local'
&gt;&gt;&gt; cfg.get('installation','prefix')
'/usr/local'
&gt;&gt;&gt;
</pre>
<p>在解析值的时候，getboolean() 方法查找任何可行的值。例如下面都是等价的:</p>
<pre class="literal-block">
log_errors = true
log_errors = TRUE
log_errors = Yes
log_errors = 1
</pre>
<p>或许配置文件和 Python 代码最大的不同在于，它并不是从上而下的顺序执行。文
件是安装一个整体被读取的。如果碰到了变量替换，它实际上已经被替换完成了。例
如，在下面这个配置中，prefix 变量在使用它的变量之前或之后定义都是可以的:</p>
<pre class="literal-block">
[installation]
library=%(prefix)s/lib
include=%(prefix)s/include
bin=%(prefix)s/bin
prefix=/usr/local
</pre>
<p>ConfigParser 有个容易被忽视的特性是它能一次读取多个配置文件然后合并成一
个配置。例如，假设一个用户像下面这样构造了他们的配置文件:</p>
<pre class="literal-block">
; ~/.config.ini
[installation]
prefix=/Users/beazley/test
[debug]
log_errors=False
</pre>
<p>读取这个文件，它就能跟之前的配置合并起来。如:</p>
<pre class="literal-block">
&gt;&gt;&gt; # Previously read configuration
&gt;&gt;&gt; cfg.get('installation', 'prefix')
'/usr/local'
&gt;&gt;&gt; # Merge in user-specific configuration
&gt;&gt;&gt; import os
&gt;&gt;&gt; cfg.read(os.path.expanduser('~/.config.ini'))
['/Users/beazley/.config.ini']
&gt;&gt;&gt; cfg.get('installation', 'prefix')
'/Users/beazley/test'
&gt;&gt;&gt; cfg.get('installation', 'library')
'/Users/beazley/test/lib'
&gt;&gt;&gt; cfg.getboolean('debug', 'log_errors')
False
&gt;&gt;&gt;
</pre>
<p>仔细观察下 prefix 变量是怎样覆盖其他相关变量的，比如 library 的设定值。产
生这种结果的原因是变量的改写采取的是后发制人策略，以最后一个为准。</p>
<p class="last">最后还有很重要一点要注意的是 Python 并不能支持.ini 文件在其他程序（比如
windows 应用程序）中的所有特性。</p>
</dd>
</dl>
</div>
<div class="section" id="section-12">
<h2>给简单脚本增加日志功能</h2>
<dl class="docutils">
<dt>问题</dt>
<dd>你希望在脚本和程序中将诊断信息写入日志文件。</dd>
<dt>解决方案</dt>
<dd><p class="first">打印日志最简单方式是使用 logging 模块。</p>
<p>代码中编码可以使用basicConfig, 也可以使用ini配置文件, 如:</p>
<pre class="literal-block">
logging.config.fileConfig('logconfig.ini')
</pre>
<p>logconfig.ini内容:</p>
<pre class="literal-block">
[loggers]
keys=root
[handlers]
keys=defaultHandler
[formatters]
keys=defaultFormatter
[logger_root]
level=INFO
handlers=defaultHandler
qualname=root
[handler_defaultHandler]
class=FileHandler
formatter=defaultFormatter
args=('app.log', 'a')
[formatter_defaultFormatter]
format=%(levelname)s:%(name)s:%(message)s
</pre>
<p class="last">如果你想修改配置，可以直接编辑文件 logconfig.ini 即可。</p>
</dd>
<dt>讨论</dt>
<dd><p class="first">尽管对于 logging 模块而已有很多更高级的配置选项，不过这里的方案对于简单
的程序和脚本已经足够了。只想在调用日志操作前先执行下 basicConfig() 函数方法，你
的程序就能产生日志输出了。
如 果 你 想 要 你 的 日 志 消 息 写 到 标 准 错 误 中， 而 不 是 日 志 文 件 中， 调 用
basicConfig() 时不传文件名参数即可。例如:</p>
<pre class="literal-block">
logging.basicConfig(level=logging.INFO)
</pre>
<p class="last">basicConfig() 在程序中只能被执行一次。如果你稍后想改变日志配置，就需要先
获取 root logger ，然后直接修改它。</p>
</dd>
</dl>
</div>
<div class="section" id="section-13">
<h2>给函数库增加日志功能</h2>
<dl class="docutils">
<dt>问题</dt>
<dd>你想给某个函数库增加日志功能，但是又不能影响到那些不使用日志功能的程序。</dd>
<dt>解决方案</dt>
<dd><p class="first">对于想要执行日志操作的函数库而已，你应该创建一个专属的 logger 对象，并且
像下面这样初始化配置:</p>
<pre class="literal-block">
# somelib.py
import logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())

# Example function (for testing)
def func():
  log.critical('A Critical Error!')
  log.debug('A debug message')
</pre>
<p>使用这个配置，默认情况下不会打印日志。
不过，如果配置过日志系统，那么日志消息打印就开始生效，例如:</p>
<pre class="last literal-block">
&gt;&gt;&gt; import logging
&gt;&gt;&gt; logging.basicConfig()
&gt;&gt;&gt; somelib.func()
CRITICAL:somelib:A Critical Error!
&gt;&gt;&gt;
</pre>
</dd>
<dt>讨论</dt>
<dd><p class="first">通常来讲，你不应该在函数库代码中自己配置日志系统，或者是已经假定有个已经
存在的日志配置了。</p>
<p>调用 getLogger(__name__) 创建一个和调用模块同名的 logger 模块。由于模块都
是唯一的，因此创建的 logger 也将是唯一的。
log.addHandler(logging.NullHandler()) 操作将一个空处理器绑定到刚刚已经
创建好的 logger 对象上。一个空处理器默认会忽略调用所有的日志消息。因此，如果使
用该函数库的时候还没有配置日志，那么将不会有消息或警告出现。</p>
<p class="last">还有一点就是对于各个函数库的日志配置可以是相互独立的，不影响其他库的日
志配置。</p>
</dd>
</dl>
</div>
<div class="section" id="section-14">
<h2>实现一个计时器</h2>
<dl class="docutils">
<dt>问题</dt>
<dd>你想记录程序执行多个任务所花费的时间</dd>
<dt>解决方案</dt>
<dd>time 模块包含很多函数来执行跟时间有关的函数。尽管如此，通常我们会在此基
础之上构造一个更高级的接口来模拟一个计时器</dd>
</dl>
</div>
<div class="section" id="cpu">
<h2>限制内存和 CPU 的使用量</h2>
<dl class="docutils">
<dt>问题</dt>
<dd>你想对在 Unix 系统上面运行的程序设置内存或 CPU 的使用限制。</dd>
<dt>解决方案</dt>
<dd><p class="first">resource 模块能同时执行这两个任务。例如，要限制 CPU 时间，可以像下面这样
做:</p>
<pre class="literal-block">
import signal
import resource
import os

def time_exceeded(signo, frame):
  print(&quot;Time's up!&quot;)
  raise SystemExit(1)

def set_max_runtime(seconds):
  # Install the signal handler and set a resource limit
  soft, hard = resource.getrlimit(resource.RLIMIT_CPU)
  resource.setrlimit(resource.RLIMIT_CPU, (seconds, hard))
  signal.signal(signal.SIGXCPU, time_exceeded)

if __name__ == '__main__':
  set_max_runtime(15)
  while True:
    pass
</pre>
<p>程序运行时，SIGXCPU 信号在时间过期时被生成，然后执行清理并退出。
要限制内存使用，设置可使用的总内存值即可，如下:</p>
<pre class="literal-block">
import resource
def limit_memory(maxsize):
  soft, hard = resource.getrlimit(resource.RLIMIT_AS)
  resource.setrlimit(resource.RLIMIT_AS, (maxsize, hard))
</pre>
<p class="last">像这样设置了内存限制后，程序运行到没有多余内存时会抛出 MemoryError 异常。</p>
</dd>
<dt>讨论</dt>
<dd><p class="first">在本节例子中，setrlimit() 函数被用来设置特定资源上面的软限制和硬限制。
<strong>软限制</strong> 是一个值，当超过这个值的时候操作系统通常会发送一个信号来限制或通知该进
程。
<strong>硬限制</strong> 是用来指定软限制能设定的最大值。通常来讲，这个由系统管理员通过设置
系统级参数来决定。尽管硬限制可以改小一点，但是最好不要使用用户进程去修改。</p>
<p>setrlimit() 函数还能被用来设置子进程数量、打开文件数以及类似系统资源的
限制。更多详情请参考 resource 模块的文档。</p>
<p class="last">需要注意的是本节内容只能适用于 Unix 系统，并且不保证所有系统都能如期工
作。比如我们在测试的时候，它能在 Linux 上面正常运行，但是在 OS X 上却不能。</p>
</dd>
</dl>
</div>
<div class="section" id="web">
<h2>启动一个 WEB 浏览器</h2>
<dl class="docutils">
<dt>问题</dt>
<dd>你想通过脚本启动浏览器并打开指定的 URL 网页</dd>
<dt>解决方案</dt>
<dd><p class="first">webbrowser 模块能被用来启动一个浏览器，并且与平台无关。例如:</p>
<pre class="literal-block">
&gt;&gt;&gt; import webbrowser
&gt;&gt;&gt; webbrowser.open('http://www.python.org')
True
&gt;&gt;&gt;
</pre>
<p>它会使用默认浏览器打开指定网页。如果你还想对网页打开方式做更多控制，还可
以使用下面这些函数:</p>
<pre class="literal-block">
&gt;&gt;&gt; # Open the page in a new browser window
&gt;&gt;&gt; webbrowser.open_new('http://www.python.org')
True
&gt;&gt;&gt;
&gt;&gt;&gt; # Open the page in a new browser tab
&gt;&gt;&gt; webbrowser.open_new_tab('http://www.python.org')
True
&gt;&gt;&gt;
</pre>
<p>这样就可以打开一个新的浏览器窗口或者标签，只要浏览器支持就行。
如果你想指定浏览器类型，可以使用 webbrowser.get() 函数来指定某个特定浏览
器。例如:</p>
<pre class="literal-block">
&gt;&gt;&gt; c = webbrowser.get('firefox')
&gt;&gt;&gt; c.open('http://www.python.org')
True
&gt;&gt;&gt; c.open_new_tab('http://docs.python.org')
True
&gt;&gt;&gt;
</pre>
<p class="last">对于支持的浏览器名称列表可查阅 <a class="reference external" href="http://docs.python.org/3/library/webbrowser.html">Python 文档</a></p>
</dd>
<dt>讨论</dt>
<dd>在脚本中打开浏览器有时候会很有用。例如，某个脚本执行某个服务器发布任务，
你想快速打开一个浏览器来确保它已经正常运行了。或者是某个程序以 HTML 网页格
式输出数据，你想打开浏览器查看结果。不管是上面哪种情况，使用 webbrowser 模块
都是一个简单实用的解决方案。</dd>
</dl>
</div>

								</article>
						</div>
					</div>
				</div>
			</section>
	</div>
</div>

				</div>
			</div>



		<!-- Sider Bar -->
		<div id="right-side-bar">
	<nav>
		<div id="top-toc-tree-container" class="fixed-container">
			<div class="toc-contents-title">
				<h4 id="toc-contents-title-text">Contents</h4>
				<!-- <span class="tool-tip-text">点击隐藏</span> -->
			</div>
			<div id="toc-tree-container">
 <ul class="toc-tree visible">
  <li class="toc-h0">
   <a class="" href="#section-2">
    通过重定向/管道/文件接受输入
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-3">
    终止程序并给出错误信息
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-4">
    解析命令行选项
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-5">
    运行时弹出密码输入提示
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-6">
    获取终端的大小
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-7">
    执行外部命令并获取它的输出
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-8">
    复制或者移动文件和目录
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-9">
    创建和解压归档文件
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-10">
    通过文件名查找文件
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-11">
    读取配置文件
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-12">
    给简单脚本增加日志功能
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-13">
    给函数库增加日志功能
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#section-14">
    实现一个计时器
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#cpu">
    限制内存和 CPU 的使用量
   </a>
  </li>
  <li class="toc-h0">
   <a class="" href="#web">
    启动一个 WEB 浏览器
   </a>
  </li>
 </ul>
</div>

		</div>
	</nav>
	<div id="sidebar-tools" class="fixed-container no-active cant-select">
		<!-- 按钮 使用 content 绘制图标 -->
	</div>
	<div id="sidebar-tool-back-top" class="fixed-container cant-select">
		<!-- 按钮 使用 content 绘制图标 -->
	</div>
		</div>

		<!-- Footer Wrapper -->
			<div id="footer-wrapper">
				<!-- Footer -->
					<section id="footer" class="container">
						<div class="row">
							<div class="8u">
								<section>
									<header>
										<h2>Latest articles</h2>
									</header>
									<ul class="dates">
										<li>
											<span class="date"> 9 <strong>09</strong></span>
											<h3><a href="yq-docs-rear-end-python-python-three--party-library-pyside6_more-Tutorial-layout-cancel-default-space-allocation.html">布局时取消默认平均分配空间行为</a></h3>
											<p><p class="first last">布局时取消默认平均分配空间行为</p>
</p>
										</li>
										<li>
											<span class="date"> 9 <strong>09</strong></span>
											<h3><a href="yq-docs-rear-end-python-python-three--party-library-pyside6_more-modules-QtWidgets.html">QtWidgets</a></h3>
											<p><p class="first last">QtWidgets</p>
</p>
										</li>
										<li>
											<span class="date"> 8 <strong>29</strong></span>
											<h3><a href="yq-docs-operating-system-Windows-tutorial-resouce-manager-right-click-menu-and-registry.html">资源管理器右键菜单与注册表</a></h3>
											<p><p class="first last">资源管理器右键菜单与注册表</p>
</p>
										</li>
										<li>
											<span class="date"> 8 <strong>28</strong></span>
											<h3><a href="yq-docs-front-end-node-Three--party-library-electron-builder.html">electron-builder</a></h3>
											<p><p class="first last">electron-builder</p>
</p>
										</li>
									</ul>
								</section>
							</div>
						</div>
						<div class="row">
							<div class="4u">
								<section>
									<header>
										<h2>Blogroll</h2>
									</header>
									<ul class="divided">
											<li><a href="https://yq-yqr.readthedocs.io/zh/blog-theme/blog.html">旧版(迁移中)</a></li>
											<li><a href="https://getpelican.com/">Pelican</a></li>
											<li><a href="https://www.python.org/">Python.org</a></li>
											<li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
									</ul>
								</section>
							</div>
							<div class="4u">
								<section>
									<header>
										<h2>Categories</h2>
									</header>
									<ul class="divided">
											<li><a href="/category/ai.html">AI</a></li>
											<li><a href="/category/an-quan.html">安全</a></li>
											<li><a href="/category/ban-ben-kong-zhi.html">版本控制</a></li>
											<li><a href="/category/cao-zuo-xi-tong.html">操作系统</a></li>
									</ul>
								</section>
							</div>

							<div class="4u">
								<section>
									<header>
										<h2>SITEMAP</h2>
									</header>

									<ul class="divided">
												<li><a href="/authors.html">作者</a></li>
												<li><a href="/categories.html">分类</a></li>
												<li><a href="/archives.html">归档</a></li>
												<li><a href="/tags.html">标签</a></li>
									</ul>
								</section>
							</div>

							<div class="4u">

								<section>
									<header>
										<h2>Contact</h2>
									</header>
									<ul class="social">
									</ul>
								</section>
							</div>
						</div>
						<div class="row">
							<div class="12u">
								<!-- Copyright -->
									<div id="copyright">
										<ul class="links">
											<li>&copy; YanQue 2021-2024	</li>
											<!-- <li>Images: <a href="http://facebook.com/DreametryDoodle">Dreametry Doodle</a> + <a href="http://iconify.it">Iconify.it</a></li>
											<li>Design: <a href="http://html5up.net">HTML5 UP</a></li> -->
										</ul>
									</div>
							</div>
						</div>
					</section>
			</div>

		</div>

		<!-- 其他 -->

			<div style="position: fixed;">
				<!-- 深色模式粒子效果 -->
				<!-- <canvas id="universe" width="1428" height="993" data-relingo-block="true" data-relingo-parsed="true"></canvas> -->
				<!-- 深色模式下添加粒子效果canvas -->
				<canvas id="universe" width="1312" height="880"></canvas>
			</div>

		<script src="/theme/js/jquery-3.7.1.min.js"></script>
		<script src="/theme/js/jquery.dropotron.js"></script>
		<script src="/theme/js/config.js"></script>
		<script src="/theme/skel-s0.4.8/skel.min.js"></script>
		<script src="/theme/skel-s0.4.8/skel-panels.min.js"></script>
		<!-- <script src="/theme/js/skel.min.js"></script>
		<script src="/theme/js/skel-panels.min.js"></script> -->
		<script src="/theme/js/backloading.js"></script>
		<script src="/theme/js/canvas/dark.js"></script>
<script type="text/javascript">
	function addEvent() {
		$("#toc-contents-title-text").click(function() {
			$("#top-toc-tree-container").toggleClass("no-active");
			$("#sidebar-tools").toggleClass("no-active");
		})
		$("#sidebar-tools").click(function() {
			$("#top-toc-tree-container").toggleClass("no-active");
			$("#sidebar-tools").toggleClass("no-active");
		})
		$("#sidebar-tool-back-top").click(function() {
			// window.scrollTo(0, 0);
			window.scrollTo({
				top: 0,
				left: 0,
				behavior: 'smooth'
			});
		})
	}
	addEvent()
</script>
		<!--[if lte IE 8]><script src="js/html5shiv.js"></script><link rel="stylesheet" href="/theme/css/ie8.css" /><![endif]-->
	</body>
</html>